<div class="main container">
    <div class="main-content">
        <div class="article-container">
    <div class="article-header">
        <h1 class="title">Тарга Toyota GR HV Sports — с механическим «автоматом»</h1>
        <div class="cover">
            <a href="https://autoreview.ru/ajax/favorite/160904" class="favorite tooltip-left" title="Добавить в избранное"></a>
            <img src="/images/Article/1609/Article_160904_860_575.jpg" alt="Тарга Toyota GR HV Sports — с механическим «автоматом»">
            <div class="text">
                                                <a href="https://autoreview.ru/news" class="rubric">Новости</a> |
                                <a href="" class="date">6 октября 2017</a>
                <span class="article-share">
    <script type="text/javascript" src="//yastatic.net/es5-shims/0.0.2/es5-shims.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="//yastatic.net/share2/share.js" charset="utf-8"></script>
    <span class="share-text" style="">Поделиться: </span>
    <div class="ya-share2" data-services="vkontakte,facebook,twitter"></div>
</span>
            </div>
        </div>
        <div class="article-preview-footer">
                                                                        <div class="author only"><img class="avatar" src="/images/Creator/1/Creator_141_40_40.jpg"><a href="/person/141"><span class="name">Игорь Владимирский</span></a></div>                                                            <div class="others">
						            </div>
            <div style="clear: both"></div>
        </div>
    </div>
    <div class="full-article">
                                    <p>На автосалоне в Токио состоится первый публичный показ новой гаммы автомобилей Toyota под <a href="https://autoreview.ru/news/toyota-predstavila-gammu-sportivnyh-modeley-s-pristavkoy-gr" target="_blank" rel="noopener noreferrer">«спортивным» суббрендом GR</a>. А привлекать внимание публики будет концепт Toyota GR HV Sports, призванный показать взгляд разработчиков на то, каким может стать недорогой спорткар с гибридной силовой установкой.</p>
<p><img src="https://autoreview.ru/images/gallery/%D0%9D%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8/2017/October/06/toyota-gr-hv-sports2.jpg" alt="" height="412" width="860" /></p>
<p>Новый концепт построен на основе серийного купе <a href="https://autoreview.ru/news/kupe-toyota-gt86-obnovilos-na-radost-poklonnikov-mehaniki" target="_blank" rel="noopener noreferrer">Toyota GT86</a>, но его внешность стилизована под гоночный прототип <a href="https://autoreview.ru/articles/avtosport/lemans17_preview" target="_blank" rel="noopener noreferrer">TS050 Hybrid</a>, который участвует в гонках на выносливость. Новый передок — со светодиодными фарами, на корме — один центральный патрубок выпускной системы и большой диффузор в бампере, а дизайн колес — точно такой же, как у гоночного болида. Вдобавок у машины вырезана секция крыши над сиденьями: это дань уважения былым моделям Toyota Sports 800 и Supra, которые имели кузов типа тарга.</p>
<p><img class="ar-slider" data-slider="[{'alt':'','src':'https://autoreview.ru/images/gallery/%D0%9D%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8/2017/October/06/toyota-gr-hv-sports3.jpg'},{'alt':'','src':'https://autoreview.ru/images/gallery/%D0%9D%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8/2017/October/06/toyota-gr-hv-sports4.jpg'},{'alt':'','src':'https://autoreview.ru/images/gallery/%D0%9D%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8/2017/October/06/toyota-gr-hv-sports5.jpg'}]" /></p>
<p>О гибридной силовой установке, которая называется THS-R (Toyota Hybrid System-Racing), компания подробностей не сообщает. Известно лишь, что тяговая батарея расположена на месте задних сидений, толку от которых все равно было немного. Трансмиссия — автоматическая: режимы переключаются крупными клавишами на центральной консоли. Но что тогда здесь делает рычаг механической коробки передач?</p>
<p><img class="ar-slider" data-slider="[{'alt':'','src':'https://autoreview.ru/images/gallery/%D0%9D%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8/2017/October/06/toyota-gr-hv-sports6.jpg'},{'alt':'','src':'https://autoreview.ru/images/gallery/%D0%9D%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8/2017/October/06/toyota-gr-hv-sports9.jpg'}]" /></p>
<p>Это фетиш, предназначенный для фанатов «механики». Рычагом можно переключать шесть передач «автомата», выбрав предварительно ручной режим кнопкой M на консоли. Причем речь не о качании селектора вперед-назад, как у многих двухпедальных автомобилей. Toyota GR HV Sports имеет достоверную имитацию механической коробки с традиционной схемой переключения! Для полного комплекта не хватает только педали сцепления. Интересно, что заднюю передачу рычагом не «воткнуть» — только кнопкой. А еще один прикол концепта — клавиша запуска двигателя, расположенная под откидной крышкой в набалдашнике рычага.</p>
<p><img class="ar-slider" data-slider="[{'alt':'','src':'https://autoreview.ru/images/gallery/%D0%9D%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8/2017/October/06/toyota-gr-hv-sports7.jpg'},{'alt':'','src':'https://autoreview.ru/images/gallery/%D0%9D%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8/2017/October/06/toyota-gr-hv-sports8.jpg'}]" /></p>
<p>Скорее всего, Toyota GR HV Sports в нынешнем виде так и останется концептом. Хотя гибридный спорткар у компании будет: новая Toyota Supra, созданная в сотрудничестве с BMW, справит дебют на этом же автосалоне в Токио! Ждать осталось недолго.</p>
                        </div>

            <div class="tags" id="tags">
                            <a href="https://autoreview.ru/tag/GRMN">GRMN</a>,                 <a href="https://autoreview.ru/tag/Toyota%20GR%20HV%20Sports">Toyota GR HV Sports</a>,                 <a href="https://autoreview.ru/tag/Toyota%20GT86">Toyota GT86</a>,                 <a href="https://autoreview.ru/tag/%D0%A2%D0%BE%D0%BA%D0%B8%D0%BE-2017">Токио-2017</a>        </div>
    
    <span class="article-share article-share-bottom">
    <script type="text/javascript" src="//yastatic.net/es5-shims/0.0.2/es5-shims.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="//yastatic.net/share2/share.js" charset="utf-8"></script>
    
    <div class="ya-share2" data-services="vkontakte,facebook,twitter"></div>
</span>
    <div class="mobile-share">
        <script type="text/javascript">
            (function(w,doc) {
                if (!w.__utlWdgt ) {
                    w.__utlWdgt = true;
                    var d = doc, s = d.createElement('script'), g = 'getElementsByTagName';
                    s.type = 'text/javascript'; s.charset='UTF-8'; s.async = true;
                    s.src = ('https:' == w.location.protocol ? 'https' : 'http')  + '://w.uptolike.com/widgets/v1/uptolike.js';
                    var h=d[g]('body')[0];
                    h.appendChild(s);
                }})(window,document);
        </script>
        <div data-background-alpha="0.0" data-buttons-color="#ffffff" data-counter-background-color="#ffffff" data-share-counter-size="12" data-top-button="true" data-share-counter-type="disable" data-share-style="1" data-mode="share" data-like-text-enable="false" data-mobile-view="true" data-icon-color="#ffffff" data-orientation="fixed-bottom" data-text-color="#000000" data-share-shape="round-rectangle" data-sn-ids="fb.vk.tw." data-share-size="30" data-background-color="#ffffff" data-preview-mobile="false" data-mobile-sn-ids="fb.vk.tw.wh.vb." data-pid="1512651" data-counter-background-alpha="1.0" data-following-enable="false" data-exclude-show-more="true" data-selection-enable="false" class="uptolike-buttons" ></div>
    </div>

        <noindex style="clear: both;display: block;">
        <div id="adfox_1486545699744815"></div>
        <script>
            window.Ya.adfoxCode.createScroll({
                ownerId: 1435,
                containerId: 'adfox_1486545699744815',
                params: {
                    p1: 'bseee',
                    p2: 'ul',
                    puid1: '',
                    puid3: '',
                    puid4: '',
                    puid5: '',
                    puid6: ''
                }
            });
        </script>
    </noindex>
    
            <div data-widget="plista_widget_belowArticle" style="position: relative"></div>
        <script type="text/javascript">
            if (!window.PLISTA) {
                window.PLISTA = {
                    publickey: '5f6deeefa49dcab68c2e6260',
                    item: {
                        objectid: "160904",
                        title: "Тарга Toyota GR HV Sports — с механическим «автоматом»",
                        text: "Тарга Toyota GR HV Sports — с механическим «автоматом»",
                        url: "https://autoreview.ru/articles/targa-toyota-gr-hv-sports-s-avtomaticheskoy-mehanikoy/targa-toyota-gr-hv-sports-s-avtomaticheskoy-mehanikoy",
                        img: "https://autoreview.ru/images/Article/1609/Article_160904_305_204.jpg",
                        category: rubric,
                        published_at: "1507276130",
                        updated_at: "1507283690",
                        magazin: ""
                    }
                };
                (function(){var n='script',d=document,s=d.createElement(n),s0=d.getElementsByTagName(n)[0];s.async='async';s.type='text/javascript';s.src=(d.location.protocol==='https:'?'https:':'http:')+'//static-RU.plista.com/async.js';s0.parentNode.insertBefore(s,s0)}());
            }
        </script>
    
    <div class="comments">
    <div id="comments">
        <comments></comments>
    </div>
</div>

<script type="text/x-template" id="alert-template">
    <div v-show="errors || success">
        <div class="clearfix"></div>
        <div class="alert" :class="{'alert-success': success, 'alert-danger': !success}">
            <span class="close" v-on:click="close">&times;</span>
            <ul v-if="!text">
                <li v-for="error in errors">{{ error }}</li>
            </ul>
            <template v-if="text">{{ errors }}</template>
            <template v-if="success">{{ success }}</template>
        </div>
    </div>
</script>
<script type="text/x-template" id="comment-template">
    <li class="comment" :id="'comment-' + comment.id" :class="{collapsed: collapsed, unread: comment.unread}" transition="fade">
        <div class="comment-content clearfix" :class="{target: target === comment.id}">
            <div class="indicator"></div>

            <div v-if="comment.author.avatar" class="avatar">
                <a :href="comment.author.url">
                    <img :src="comment.author.avatar" :alt="comment.author.name">
                </a>
            </div>

            <div class="comment-body">
                <div class="comment-header">
                    <a v-if="!comment.author.url" href="/profile/{{ comment.author.login }}" target="_blank" class="author">{{ comment.author.name }} ({{ comment.author.login }})</a>
                    <a v-if="comment.author.url" href="{{ comment.author.url }}" target="_blank" class="author">{{ comment.author.name }}</a>

                    <a v-if="parent"
                       v-on:click="target = parent.id"
                       :href="'#!comment=' + parent.id"
                       class="parent-author">
                        <span class="comment-reply">R</span>
                        {{ parent.author.name }}
                    </a>

                    <a :href="'#!comment=' + comment.id" class="time-ago" v-on:click="target = comment.id">
                        <time :datetime="comment.created_at" :title="comment.created_at_f"></time>
                    </a>
                    <a v-if="moderate" :href="comment.edit_link" class="admin-link" target="_blank">#</a>

                    <div class="pull-right" v-if="authorized()">
                        <span class="report-comment" title="{{ comment.reported ? 'Жалоба принята' : 'Пожаловаться' }}" v-on:click="report" :class="{active: comment.reported}"></span>
                    </div>
                </div>

                <div class="comment-body-inner" v-show="!showEdit">
                    <div v-if="comment.status !== 'approved'" class="hold">Ваш комментарий находится на модерации.</div>
                    <a v-if="comment.upvotes - comment.downvotes <= -5" v-on:click="showHidden = !showHidden" class="toggle-hidden" :class="{collapsed: !showHidden}">{{ showHidden ? 'показать комментарий' : 'скрыть комментарий' }}</a>
                    <div v-if="comment.upvotes - comment.downvotes > -5 || !showHidden" class="comment-message">{{{ comment.contentHTML | emoji }}}</div>
                </div>

                <!-- Votes -->
                <div class="comment-footer" v-if="!showEdit">
                    <div class="comment-voting" v-if="votes()">
                        <span class="upvotes">{{ comment.upvotes || '' }}</span>
                        <a href="#" title="+" class="upvote" :class="{voted: upvoted}" v-on:click="upvote">
                            <span class="vote-up"></span></a>
                        
                    </div>

                    <a v-if="replies() && !user.isBanned && (!subscribersOnly || !(subscribersOnly && !user.isSubscriber))" v-on:click="reply" href="#" class="reply">Ответить</a>
                    <a v-if="editable" v-on:click="edit" href="#" class="edit">Редактировать</a>
                    <a v-if="removable && comment.replies.length == 0 || moderate" v-on:click="destroy(comment, $event)" href="#" class="delete">Удалить</a>
                </div>

                <!-- Edit form -->
                <form class="clearfix" v-if="showEdit" v-on:submit="save">
                    <div class="comments-wrap">
                        <ul class="comments-header">
                            <li v-on:click="textFormatting($event, 'bold')" title="Жирный"><a href="#" class="bold">B</a></li>
                            <li v-on:click="textFormatting($event, 'italic')" title="Курсив"><a href="#" class="italic">I</a></li>
                            <li v-on:click="textFormatting($event, 'quote')" title="Цитата"><a href="#" class="quote">“„</a></li>
                            <li :class="{active: preview}"><a href="#" v-on:click="previewToggle">предпросмотр</a></li>
                        </ul>
                        <textarea v-model="content" v-on:click="focus = true" v-if="!preview" v-disable="loading" class="form-control" wrap="hard"
                                  :maxlength="maxLength" placeholder="Комментарий">{{{ comment.content }}}</textarea>

                        <div class="preview-area" v-if="preview">{{{ previewContent }}}</div>
                    </div>

                    <div class="comments-action">
                        <button type="submit" class="btn btn-success btn-sm" v-loading="{state: loading, text: 'Сохранение...'}">
                            Сохранить                        </button>

                        <button type="button" class="btn btn-default btn-sm" v-on:click="showEdit = false">
                            Отмена                        </button>
                    </div>

                    <alert :errors="errors"></alert>
                </form>
            </div>

            <post-form v-if="showReply"
                       :focus="true"
                       :show.sync="showReply"
                       :parent="comment"
                       :total.sync="total">
            </post-form>
        </div>

        <ul class="comment-list children">
            <comment v-for="comm in comment.replies" v-show="comment.replies"
                     :comment.sync="comm"
                     :total.sync="total"
                     :parent.sync="comment"
                     :target.sync="target">
            </comment>
        </ul>
    </li>
</script>
<script type="text/x-template" id="comments-template">
    <div v-if="initialized" transition="expand">
        <div class="comment-sort pull-right dropdown">
            <a href="#" v-on:click="sortToggle($event)" class="dropdown-toggle c-sort" data-toggle="dropdown">
                {{ sortText }} <span class="caret"></span>
            </a>
            <ul v-show="sort_dropdown" class="dropdown-menu">
                <li v-for="(key, val) in sortOptions" :class="{active: sort == key}">
                    <a href="#" v-on:click="sortBy(key, $event)">{{ val }}</a>
                </li>
            </ul>
        </div>

        <h3 class="total">
            {{ total + ' ' + pluralCount }}
        </h3>

        <a href="#" v-on:click="subscribe($event)" class="comments-notification tooltip-right" v-if="closed == 0 && !user.isBanned && (!subscribersOnly || !(subscribersOnly && !user.isSubscriber))" v-bind:class="{ active: isSubscribed }" title="Подписаться на новые сообщения"></a>
    </div>

    <div v-if="!initialized" class="spinner">Загрузка...</div>

    <div v-if="initialized">
        <div class="alert" v-if="closed == 1">Добавление новых комментариев к материалу отключено</div>
        <div class="alert alert-auth" v-if="closed == 0 && !authorized()">Вы должны <a href="#" class="comments-auth">авторизоваться</a>, чтобы оставить комментарий</div>
        <div class="alert alert-auth" v-if="user.isBanned">Нарушены правила <a href="/club/rules" target="_blank">комментирования</a>. Вы сможете снова оставлять комментарии после {{ user.isBanned }}.</div>
        <!-- Post form -->
        <post-form :comment-list.sync="commentList" :total.sync="total" v-if="closed == 0 && !user.isBanned && (!subscribersOnly || !(subscribersOnly && !user.isSubscriber))"></post-form>
        
        <div class="popup-club-add-comments" v-if="closed == 0 && (!authorized() || !user.isSubscriber)">
            <div class="popup-club-add-comments-subscription">
                <p class="title">Комментирование в клубе доступно только подписчикам</p>
                <div class="subscription">
                    <div class="subscription-wrapp">
                        <div class="subscription-left">
                            <form action="/subscribe/confirm" method="post">
                                <input type="hidden" name="_token" value="pGZU6ssbtGqI9d0cPOq4poooNEsWr8SKIzYxhuJs">
                                <input type="hidden" name="subscribe-period" value="1">
                                <div class="title">Подписка на месяц</div>
                                <div class="price"><span>229</span></div>
                                <input type="submit" value="Выбрать" class="button">
                            </form>
                        </div>
                        <div class="subscription-right">
                            <form action="/subscribe/confirm" method="post">
                                <input type="hidden" name="_token" value="pGZU6ssbtGqI9d0cPOq4poooNEsWr8SKIzYxhuJs">
                                <input type="hidden" name="subscribe-period" value="2">
                                <img src="/static/svg/label.svg" class="profitable">
                                <div class="title">Подписка на год</div>
                                <div class="price"><span class="sale">2748</span><span>1590</span></div>
                                <input type="submit" value="Выбрать" class="button">
                            </form>
                        </div>
                    </div>
                    <a href="/subscribe#reasons" class="sub" target="_blank">Еще 6 причин подписаться на сайт</a>
                    <a href="" class="button blue already-subscribe" v-if="!authorized()">я уже подписан</a>
                </div>
            </div>
        </div>

        <div class="clearfix"></div>
        <div v-show="loading" class="spinner">Загрузка...</div>

        <!-- Coment list -->
        <ul class="comment-list" v-if="!loading" transition="fade">
            <comment v-for="comment in commentList"
                :comment.sync="comment"
                :total.sync="total"
                :target.sync="target">
            </comment>
        </ul>

        <!-- Pagination -->
        <div class="text-center" v-if="!loading && pagination.total > pagination.per_page">
            <ul class="pagination pagination-sm">
                <li :class="{disabled: pagination.current_page == 1}">
                    <a :href="'#!page=' + pagination.prev_page" v-on:click="changePage(pagination.prev_page, $event)">&laquo;</a>
                </li>

                <li v-if="pagination.first_adjacent_page > 1">
                    <a href="#!page=1" v-on:click="changePage(1, $event)">1</a>
                </li>

                <li v-if="pagination.first_adjacent_page > 2" class="disabled"><a>...</a></li>

                <template v-for="index in pagination.last_adjacent_page">
                    <li v-if="index + 1 >= pagination.first_adjacent_page" :class="{active: pagination.current_page == index + 1}">
                        <a :href="'#!page=' + (index + 1)" v-on:click="changePage(index + 1, $event)">{{ index + 1 }}</a>
                    </li>
                </template>

                <li v-if="pagination.last_adjacent_page < pagination.last_page - 1" class="disabled"><a>...</a></li>

                <li v-if="pagination.last_adjacent_page < pagination.last_page">
                    <a :href="'#!page=' + pagination.last_page" v-on:click="changePage(pagination.last_page, $event)">{{ pagination.last_page }}</a>
                </li>

                <li :class="{disabled: pagination.current_page === pagination.last_page}">
                    <a :href="'#!page=' + pagination.next_page" v-on:click="changePage(pagination.next_page, $event)">&raquo;</a>
                </li>
            </ul>
        </div>
    </div>
</script>
<script type="text/x-template" id="post-form-template">
    <form v-show="show && authorized()" v-on:submit="onSubmit">
        <div class="comments-wrap">
            <div v-if="focus">
                <div v-if="captchaRequired" class="form-group" id="recaptcha"></div>
            </div>

            <ul class="comments-header">
                <li v-on:click="textFormatting($event, 'bold')" title="Жирный"><a href="#" class="bold">B</a></li>
                <li v-on:click="textFormatting($event, 'italic')" title="Курсив"><a href="#" class="italic">I</a></li>
                <li v-on:click="textFormatting($event, 'quote')" title="Цитата"><a href="#" class="quote">“„</a></li>
                <li :class="{active: preview}"><a href="#" v-on:click="previewToggle">предпросмотр</a></li>
            </ul>
            <textarea v-model="content" v-on:click="focus = true" v-if="!preview" v-disable="loading" class="form-control" wrap="hard"
                    :maxlength="maxLength" :placeholder="parent ? 'Ваш комментарий...' : 'Ваш комментарий...'"
            ></textarea>

            <div class="preview-area" v-if="preview">{{{ previewContent }}}</div>

            

        </div>
        <div class="comments-action">
            <button type="submit" v-loading="{state: loading, text: 'Отправка...'}">
                Отправить            </button>

            <button type="button" v-if="commentList.length == 0" v-on:click="cancel">
                Отмена            </button>
        </div>

        
        <alert :errors="errors"></alert>
    </form>
</script>

<script>
    window.commentsConfig = {
        pageId: '160904',
        pageType: 'article',
        authorized: true,
        authenticated: true,
        captchaRequired: false,
        votes: true,
        replies: true,
        maxLength: 1500,
        sortBy: 1,
        sortOptions: {
            1: 'Новые сверху',
            2: 'Старые сверху',
            3: 'Лучшие сверху',
        },
        user: {"id":1155252,"name":"\u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440 \u0416\u0430\u0440\u0438\u043a\u043e\u0432","login":"skreets","email":"skreets.ru@gmail.com","avatar":"\/images\/Avatar\/11552\/Avatar_1155252_40_40.jpg","admin":false,"rating":"2","isSubscriber":true,"isBanned":false,"guest":false},
        uid: 'xKDBRPK6SjEJ05yh',
        storageKey: 'comment_author',
        permalink: 'https://autoreview.ru/news/targa-toyota-gr-hv-sports-s-avtomaticheskoy-mehanikoy',
        referrer: 'https://autoreview.ru/',
        csrfToken: 'pGZU6ssbtGqI9d0cPOq4poooNEsWr8SKIzYxhuJs',
        recaptcha: '',
        routes: {
            index: 'https://autoreview.ru/comments',
            store: 'https://autoreview.ru/comments',
            update: 'https://autoreview.ru/comments/:id',
            vote: 'https://autoreview.ru/comments/:id/vote',
            notifications: 'https://autoreview.ru/comments/notifications',
            destroy: 'https://autoreview.ru/comments/:id',
            report: 'https://autoreview.ru/comments/:id/report'
        },
                closed: '0',
        subscribersOnly: ''
    };
</script>
<script>(function(){/** @const */ var HINT={};
/** @const */ HINT.EMOTICONS_NOT_AFTER=0;
/** @const */ HINT.LITEDOWN_DECODE_HTML_ENTITIES=0;
/** @const */ HINT.RULE_AUTO_CLOSE=0;
/** @const */ HINT.RULE_AUTO_REOPEN=0;
/** @const */ HINT.RULE_BREAK_PARAGRAPH=0;
/** @const */ HINT.RULE_CREATE_PARAGRAPHS=0;
/** @const */ HINT.RULE_DISABLE_AUTO_BR=0;
/** @const */ HINT.RULE_ENABLE_AUTO_BR=1;
/** @const */ HINT.RULE_IGNORE_TAGS=0;
/** @const */ HINT.RULE_IGNORE_TEXT=0;
/** @const */ HINT.RULE_IGNORE_WHITESPACE=0;
/** @const */ HINT.RULE_IS_TRANSPARENT=0;
/** @const */ HINT.RULE_PREVENT_BR=0;
/** @const */ HINT.RULE_SUSPEND_AUTO_BR=0;
/** @const */ HINT.RULE_TRIM_FIRST_LINE=0;
/** @const */ HINT.attributeDefaultValue=0;
/** @const */ HINT.attributeGenerator=0;
/** @const */ HINT.closeAncestor=0;
/** @const */ HINT.closeParent=0;
/** @const */ HINT.createChild=0;
/** @const */ HINT.fosterParent=0;
/** @const */ HINT.namespaces=0;
/** @const */ HINT.postProcessing=0;
/** @const */ HINT.requireAncestor=0;
/** @const */ var xsl="<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\"><xsl:output method=\"html\" encoding=\"utf-8\" indent=\"no\"\/><xsl:param$wAMAZON_ASSOCIATE_TAG\"\/><xsl:param$wAMAZON_ASSOCIATE_TAG_CA\"\/><xsl:param$wAMAZON_ASSOCIATE_TAG_DE\"\/><xsl:param$wAMAZON_ASSOCIATE_TAG_ES\"\/><xsl:param$wAMAZON_ASSOCIATE_TAG_FR\"\/><xsl:param$wAMAZON_ASSOCIATE_TAG_IN\"\/><xsl:param$wAMAZON_ASSOCIATE_TAG_IT\"\/><xsl:param$wAMAZON_ASSOCIATE_TAG_JP\"\/><xsl:param$wAMAZON_ASSOCIATE_TAG_UK\"\/>$eABCNEWS\"><$l$fabcnews\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/abcnews.go.com\/video\/embed?id={@id}\"$g$b\/><\/$l><\/$l>$h$eAMAZON\"><$l$famazon\"$g$c120px\"><$l$g$a200%\">$d$g$b><$t$wsrc\">\/\/<$u><$r$q@tld='es'or@tld='it'\">rcm-eu.amazon-adsystem.com\/e\/cm?lt1=_blank&amp;bc1=FFFFFF&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;p=8&amp;l=as1&amp;f=ifr&amp;asins=$j@id\"\/>&amp;o=<$u><$r$q@tld='es'\">30<\/$r><$p>29<\/$p><\/$u>&amp;t=<$u><$r$q@tld='es'and$AMAZON_ASSOCIATE_TAG_ES\">$j$AMAZON_ASSOCIATE_TAG_ES\"\/><\/$r><$r$q@tld='it'and$AMAZON_ASSOCIATE_TAG_IT\">$j$AMAZON_ASSOCIATE_TAG_IT\"\/><\/$r><$p>_<\/$p><\/$u><\/$r><$p>ws-<$u><$r$q@tld='in'\">in<\/$r><$r$q@tld='jp'\">fe<\/$r><$r$q@tld and contains('desfrituk',@tld)\">eu<\/$r><$p>na<\/$p><\/$u>.amazon-adsystem.com\/widgets\/q?ServiceVersion=20070822&amp;OneJS=1&amp;Operation=GetAdHtml&amp;MarketPlace=<$u><$r$q@tld\">$jtranslate(@tld,'acdefijknprstu','ACDEFIJBNPRSTG')\"\/><\/$r><$p>US<\/$p><\/$u>&amp;ad_type=product_link&amp;tracking_id=<$u><$r$q@tld='ca'\">$j$AMAZON_ASSOCIATE_TAG_CA\"\/><\/$r><$r$q@tld='de'\">$j$AMAZON_ASSOCIATE_TAG_DE\"\/><\/$r><$r$q@tld='fr'\">$j$AMAZON_ASSOCIATE_TAG_FR\"\/><\/$r><$r$q@tld='in'\">$j$AMAZON_ASSOCIATE_TAG_IN\"\/><\/$r><$r$q@tld='jp'\">$j$AMAZON_ASSOCIATE_TAG_JP\"\/><\/$r><$r$q@tld='uk'\">$j$AMAZON_ASSOCIATE_TAG_UK\"\/><\/$r><$r$q$AMAZON_ASSOCIATE_TAG\">$j$AMAZON_ASSOCIATE_TAG\"\/><\/$r><$p>-20<\/$p><\/$u>&amp;marketplace=amazon&amp;region=<$u><$r$q@tld\">$jtranslate(@tld,'acdefijknprstu','ACDEFIJBNPRSTG')\"\/><\/$r><$p>US<\/$p><\/$u>&amp;asins=$j@id\"\/>&amp;show_border=true&amp;link_opens_in_new_window=true<\/$p><\/$u><\/$t><\/$z><\/$l><\/$l>$h$eAUDIOBOOM\"><$z$faudioboom\"$m\"$sno\"$k\/\/audioboom.com\/posts\/{@id}\/embed\/v3\"$gborder:0;height:150px;max-width:700px;width:100%\"\/>$h$eAUDIOMACK\"><$u><$r$q@mode='album'\"><$z$faudiomack\"$m\"$sno\"$khttps:\/\/www.audiomack.com\/embed\/album\/{@id}\"$gborder:0;height:400px;max-width:900px;width:100%\"\/><\/$r><$p><$z$faudiomack\"$m\"$sno\"$khttps:\/\/www.audiomack.com\/embed\/song\/{@id}\"$gborder:0;height:252px;max-width:900px;width:100%\"\/><\/$p><\/$u>$h$eBANDCAMP\"><$l$fbandcamp\"$g$c400px\"><$l$g$a100%\">$d$g$b><$t$wsrc\">\/\/bandcamp.com\/EmbeddedPlayer\/size=large\/minimal=true\/<$u><$r$q@album_id\">album=$j@album_id\"\/><xsl:if$q@track_num\">\/t=$j@track_num\"\/><\/xsl:if><\/$r><$p>track=$j@track_id\"\/><\/$p><\/$u><\/$t><\/$z><\/$l><\/$l>$h$eBBCNEWS\"><$l$fbbcnews\"$g$c640px\"><$l$g$a56.25%\">$d$g$b><$t$wsrc\">\/\/www.bbc.com<$u><$r$qstarts-with(@playlist,'\/news\/')and contains(@playlist,'A')\">$jsubstring-before(@playlist,'A')\"\/><\/$r><$p>\/news\/$j@id\"\/><\/$p><\/$u>\/embed<\/$t><\/$z><\/$l><\/$l>$h$eBLAB\"><$l$fblab\"$g$c400px\"><$l$g$a100%\">$d$khttps:\/\/blab.im\/{@id}\"$g$b\/><\/$l><\/$l>$h$eBLEACHERREPORT\"><$l$fbleacherreport\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/bleacherreport.com\/video_embed?id={@id}\"$g$b\/><\/$l><\/$l>$h$eBREAK\"><$l$fbreak\"$g$c464px\"><$l$g$a60.344828%\">$d$k\/\/break.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eBRIGHTCOVE\"><$l$fbrightcove\"$g$c640px\"><$l$g$a56.25%\">$d$khttps:\/\/link.brightcove.com\/services\/player\/bcpid{@bcpid}?bckey={@bckey}&amp;bctid={@bctid}&amp;secureConnections=true&amp;secureHTMLConnections=true&amp;autoStart=false&amp;height=100%25&amp;width=100%25\"$g$b\/><\/$l><\/$l>$h$eC\"><code>$x<\/code>$h$eCBSNEWS\"><$l$fcbsnews\"$g$c640px\"><$u><$r$q@pid\"><$l$g$a62.1875%;padding-bottom:calc(56.25% + 38px)\"><object data=\"\/\/www.cbsnews.com\/common\/video\/cbsnews_player.swf\"$g$o type=\"$v$y\">$n<param$wflashvars\" value=\"pType=embed&amp;si=254&amp;pid={@pid}\"\/><\/object><\/$l><\/$r><$p><$l$g$a62.5%;padding-bottom:calc(56.25% + 40px)\"><object data=\"\/\/i.i.cbsi.com\/cnwk.1d\/av\/video\/cbsnews\/atlantis2\/cbsnews_player_embed.swf\"$g$o type=\"$v$y\">$n<param$wflashvars\" value=\"si=254&amp;contentValue={@id}\"\/><\/object><\/$l><\/$p><\/$u><\/$l>$h$eCNBC\"><$l$fcnbc\"$g$c400px\"><$l$g$a95%\"><object data=\"\/\/plus.cnbc.com\/rssvideosearch\/action\/player\/id\/{@id}\/code\/cnbcplayershare\"$g$o type=\"$v$y\">$n<\/object><\/$l><\/$l>$h$eCNN\"><$l$fcnn\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/edition.cnn.com\/video\/api\/embed.html#\/video\/{@id}\"$g$b\/><\/$l><\/$l>$h$eCNNMONEY\"><$l$fcnnmoney\"$g$c560px\"><$l$g$a64.285714%\">$d$k\/\/money.cnn.com\/.element\/ssi\/video\/7.0\/players\/embed.player.html?videoid=video\/{@id}&amp;width=560&amp;height=360\"$g$b\/><\/$l><\/$l>$h$eCODE\"><pre>\n\t\t\t\t\t<code>\n\t\t\t\t\t\t<xsl:if$q@lang\">\n\t\t\t\t\t\t\t<$t$wclass\">\n\t\t\t\t\t\t\t\t<xsl:text>language-<\/xsl:text>\n\t\t\t\t\t\t\t\t$j@lang\"\/>\n\t\t\t\t\t\t\t<\/$t>\n\t\t\t\t\t\t<\/xsl:if>\n\t\t\t\t\t\t$x\n\t\t\t\t\t<\/code>\n\t\t\t\t<\/pre>$h$eCOLLEGEHUMOR\"><$l$fcollegehumor\"$g$c600px\"><$l$g$a61.5%\">$d$k\/\/www.collegehumor.com\/e\/{@id}\"$g$b\/><\/$l><\/$l>$h$eCOMEDYCENTRAL\"><$l$fcomedycentral\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/media.mtvnservices.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eCOUB\"><$l$fcoub\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/coub.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eDAILYMOTION\"><$l$fdailymotion\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.dailymotion.com\/embed\/video\/{@id}\"$g$b\/><\/$l><\/$l>$h$eDEL|EM|H1|H2|H3|H4|H5|H6|LI|STRONG|SUP|p\"><xsl:element$w{translate(name(),'DEGHILMNOPRSTU','deghilmnoprstu')}\">$x<\/xsl:element>$h$eDEMOCRACYNOW\"><$l$fdemocracynow\"$g$c640px\"><$l$g$a56.25%\">$d$g$b><$t$wsrc\">\/\/www.democracynow.org\/embed\/<$u><$r$qcontains(@id,'\/headlines')\">headlines\/$jsubstring-before(@id,'\/headlines')\"\/><\/$r><$r$qstarts-with(@id,'2')\">story\/$j@id\"\/><\/$r><$r$qstarts-with(@id,'shows\/')\">show\/$jsubstring-after(@id,'\/')\"\/><\/$r><$p>$j@id\"\/><\/$p><\/$u><\/$t><\/$z><\/$l><\/$l>$h$eDUMPERT\"><$l$fdumpert\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.dumpert.nl\/embed\/{translate(@id,'_','\/')}\/\"$g$b\/><\/$l><\/$l>$h$eEIGHTTRACKS\"><$l$feighttracks\"$g$c400px\"><$l$g$a100%\">$d$k\/\/8tracks.com\/mixes\/{@id}\/player_v3_universal\"$g$b\/><\/$l><\/$l>$h$eEMAIL\"><a href=\"mailto:{@email}\">$x<\/a>$h$eESC\">$x$h$eESPN\"><$l$fespn\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.espn.com\/core\/video\/$z?id={@id}\"$g$b\/><\/$l><\/$l>$h$eFACEBOOK\"><$z$ffacebook\"$m\" onload=\"$i$sno\"$khttps:\/\/s9e.github.io\/$z\/facebook.min.html#{@type}{@id}\"$gborder:0;height:360px;max-width:640px;width:100%\"\/>$h$eFLICKR\"><$l$fflickr\"$g$c500px\"><$l$g$a100%\">$d$khttps:\/\/www.flickr.com\/photos\/_\/{@id}\/player\/\"$g$b\/><\/$l><\/$l>$h$eFORATV\"><$l$fforatv\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/library.fora.tv\/embed?id={@id}&amp;type=c\"$g$b\/><\/$l><\/$l>$h$eFOXNEWS\"><$l$ffoxnews\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/video.foxnews.com\/v\/video-embed.html?video_id={@id}\"$g$b\/><\/$l><\/$l>$h$eFUNNYORDIE\"><$l$ffunnyordie\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.funnyordie.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eGAMESPOT\"><$l$fgamespot\"$g$c640px\"><$l$g$a62.5%\">$d$k\/\/www.gamespot.com\/videos\/embed\/{@id}\/\"$g$b\/><\/$l><\/$l>$h$eGAMETRAILERS\"><$l$fgametrailers\"$g$c640px\"><$l$g$a56.25%\">$d$g$b><$t$wsrc\"><$u><$r$qstarts-with(@id,'mgid:')\">\/\/media.mtvnservices.com\/embed\/$j@id\"\/><\/$r><$p>\/\/embed.gametrailers.com\/embed\/$j@id\"\/>?embed=1&amp;suppressBumper=1<\/$p><\/$u><\/$t><\/$z><\/$l><\/$l>$h$eGETTY\"><$l$fgetty\"$g$c{@width}px\"><$l><$t$wstyle\">display:block;overflow:hidden;position:relative;<xsl:if$q@width&gt;0\">padding-bottom:$j100*(@height+49)div@width\"\/>%;padding-bottom:calc($j100*@height div@width\"\/>% + 49px)<\/xsl:if><\/$t>$d$k\/\/embed.gettyimages.com\/embed\/{@id}?et={@et}&amp;sig={@sig}\"$g$b\/><\/$l><\/$l>$h$eGFYCAT\"><$l$fgfycat\"$g$c{@width}px\"><$l><$t$wstyle\">display:block;overflow:hidden;position:relative;<xsl:if$q@width&gt;0\">padding-bottom:$j100*@height div@width\"\/>%<\/xsl:if><\/$t>$d$k\/\/gfycat.com\/$z\/{@id}\"$g$b\/><\/$l><\/$l>$h$eGIFS\"><$l$fgifs\"$g$c{@width}px\"><$l><$t$wstyle\">display:block;overflow:hidden;position:relative;<xsl:if$q@width&gt;0\">padding-bottom:$j100*@height div@width\"\/>%<\/xsl:if><\/$t>$d$k\/\/gifs.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eGIST\"><$z$fgist\"$m\" onload=\"$i$s\"$khttps:\/\/s9e.github.io\/$z\/gist.min.html#{@id}\"$gborder:0;height:180px;width:100%\"\/>$h$eGLOBALNEWS\"><$l$fglobalnews\"$g$c560px\"><$l$g$a67.321429%\">$d$k\/\/globalnews.ca\/video\/embed\/{@id}\/\"$g$b\/><\/$l><\/$l>$h$eGOFUNDME\"><$l$fgofundme\"$g$c258px\"><$l$g$a131.007752%\"><object data=\"\/\/funds.gofundme.com\/Widgetflex.swf\"$g$o type=\"$v$y\">$n<param$wflashvars\" value=\"page={@id}\"\/><\/object><\/$l><\/$l>$h$eGOOGLEDRIVE\"><$l$fgoogledrive\"$g$c640px\"><$l$g$a75%\">$d$k\/\/drive.google.com\/file\/d\/{@id}\/preview\"$g$b\/><\/$l><\/$l>$h$eGOOGLEPLUS\"><$z$fgoogleplus\"$m\" onload=\"$i$sno\"$gborder:0;height:240px;max-width:450px;width:100%\"><$t$wsrc\">https:\/\/s9e.github.io\/$z\/googleplus.min.html#<$u><$r$q@oid\">$j@oid\"\/><\/$r><$p>+$j@name\"\/><\/$p><\/$u>\/posts\/$j@pid\"\/><\/$t><\/$z>$h$eGOOGLESHEETS\"><$z$fgooglesheets\"$m\"$sno\"$khttps:\/\/docs.google.com\/spreadsheets\/d\/{@id}\/pubhtml?widget=true&amp;headers=false#gid={@gid}\"$gborder:0;height:500px;resize:vertical;width:100%\"\/>$h$eHEALTHGURU\"><$l$fhealthguru\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.healthguru.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eHR\"><hr\/>$h$eHUDL\"><$l$fhudl\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.hudl.com\/embed\/athlete\/{@athlete}\/highlights\/{@highlight}\"$g$b\/><\/$l><\/$l>$h$eHULU\"><$l$fhulu\"$g$c640px\"><$l$g$a56.25%\">$d$khttps:\/\/secure.hulu.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eHUMORTVNL\"><$l$fhumortvnl\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/humortv.vara.nl\/embed.{@id}.html\"$g$b\/><\/$l><\/$l>$h$eIGN\"><$l$fign\"$g$c468px\"><$l$g$a56.196581%\">$d$k\/\/widgets.ign.com\/video\/embed\/content.html?url={@id}\"$g$b\/><\/$l><\/$l>$h$eIMDB\"><$l$fimdb\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.imdb.com\/video\/imdb\/vi{@id}\/imdb\/embed?autoplay=false&amp;width=640\"$g$b\/><\/$l><\/$l>$h$eIMG\"><img$k{@src}\"\/>$h$eIMGUR\"><$z$fimgur\"$m\" onload=\"var b=Math.random();window.addEventListener('message',function(a){{a.data.id==b&amp;&amp;(style.height=a.data.height+'px',style.width=a.data.width+'px')}});contentWindow.postMessage('s9e:'+b,'https:\/\/s9e.github.io')\"$sno\"$gborder:0;height:450px;max-width:100%;width:568px\"><$t$wsrc\">https:\/\/s9e.github.io\/$z\/imgur.min.html#<xsl:if$q@type='album'and not(starts-with(@id,'a\/'))\">a\/<\/xsl:if>$j@id\"\/><\/$t><\/$z>$h$eINDIEGOGO\"><$l$findiegogo\"$g$c222px\"><$l$g$a200.45045%\">$d$k\/\/www.indiegogo.com\/project\/{@id}\/embedded\"$g$b\/><\/$l><\/$l>$h$eINSTAGRAM\"><$z$finstagram\"$m\" onload=\"$i$sno\"$khttps:\/\/s9e.github.io\/$z\/instagram.min.html#{@id}\"$gborder:0;height:640px;max-width:640px;width:100%\"\/>$h$eINTERNETARCHIVE\"><$l$finternetarchive\"$g$c{@width}px\"><$l><$t$wstyle\">display:block;overflow:hidden;position:relative;<xsl:if$q@width&gt;0\">padding-bottom:$j100*@height div@width\"\/>%<\/xsl:if><\/$t>$d$khttps:\/\/archive.org\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eIZLESENE\"><$l$fizlesene\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.izlesene.com\/embedplayer\/{@id}\"$g$b\/><\/$l><\/$l>$h$eJWPLATFORM\"><$l$fjwplatform\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/content.jwplatform.com\/players\/{@id}.html\"$g$b\/><\/$l><\/$l>$h$eKHL\"><$l$fkhl\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/video.khl.ru\/$z\/feed\/start\/{@id}?type_id=18&amp;width=560&amp;height=315\"$g$b\/><\/$l><\/$l>$h$eKICKSTARTER\"><$u><$r$q@video\"><$l$fkickstarter\"$g$c480px\"><$l$g$a75%\">$d$k\/\/www.kickstarter.com\/projects\/{@id}\/widget\/video.html\"$g$b\/><\/$l><\/$l><\/$r><$p><$l$fkickstarter\"$g$c220px\"><$l$g$a190.909091%\">$d$k\/\/www.kickstarter.com\/projects\/{@id}\/widget\/card.html\"$g$b\/><\/$l><\/$l><\/$p><\/$u>$h$eKISSVIDEO\"><$l$fkissvideo\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.kissvideo.click\/embed.php?vid={@id}\"$g$b\/><\/$l><\/$l>$h$eLIBSYN\"><$z$flibsyn\"$m\"$sno\"$k\/\/html5-player.libsyn.com\/embed\/episode\/id\/{@id}\/height\/45\/width\/900\/theme\/standard\/direction\/no\/autoplay\/no\/autonext\/no\/thumbnail\/no\/preload\/no\/no_addthis\/no\/\"$gborder:0;height:45px;max-width:900px;width:100%\"\/>$h$eLIST\"><$u>\n\t\t\t\t\t<$r$qnot(@type)\">\n\t\t\t\t\t\t<ul>$x<\/ul>\n\t\t\t\t\t<\/$r>\n\t\t\t\t\t<$p>\n\t\t\t\t\t\t<ol><xsl:copy-of select=\"@start\"\/>$x<\/ol>\n\t\t\t\t\t<\/$p>\n\t\t\t\t<\/$u>$h$eLIVECAP\"><$l$flivecap\"$g$c640px\"><$l$g$a56.25%\">$d$khttps:\/\/www.livecap.tv\/s\/embed\/{@channel}\/{@id}\"$g$b\/><\/$l><\/$l>$h$eLIVELEAK\"><$l$fliveleak\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.liveleak.com\/ll_embed?i={@id}\"$g$b\/><\/$l><\/$l>$h$eLIVESTREAM\"><$l$flivestream\"$g$c640px\"><$l$g$a56.25%\">$d$g$b><$t$wsrc\"><$u><$r$q@clip_id\">\/\/cdn.livestream.com\/embed\/$j@channel\"\/>?layout=4&amp;autoplay=false&amp;clip=$j@clip_id\"\/><\/$r><$p>\/\/livestream.com\/accounts\/$j@account_id\"\/>\/events\/$j@event_id\"\/><xsl:if$q@video_id\">\/videos\/$j@video_id\"\/><\/xsl:if>\/player?autoPlay=false<\/$p><\/$u><\/$t><\/$z><\/$l><\/$l>$h$eMAILRU\"><$l$fmailru\"$g$c560px\"><$l$g$a61.071429%\">$d$k\/\/videoapi.my.mail.ru\/videos\/embed\/{@id}.html\"$g$b\/><\/$l><\/$l>$h$eMEDIUM\"><$z$fmedium\"$m\" onload=\"window.addEventListener('message',function(a){{a=a.data.split('::');'m'===a[0]&amp;&amp;0&lt;src.indexOf(a[1])&amp;&amp;a[2]&amp;&amp;(style.height=a[2]+'px')}})\"$sno\"$khttps:\/\/api.medium.com\/embed?type=story&amp;path=%2F%2F{@id}&amp;id={translate(@id,'abcdef','111111')}\"$gborder:1px solid;border-color:#eee #ddd #bbb;border-radius:5px;box-shadow:rgba(0,0,0,.15) 0 1px 3px;height:400px;max-width:400px;width:100%\"\/>$h$eMETACAFE\"><$l$fmetacafe\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.metacafe.com\/embed\/{@id}\/\"$g$b\/><\/$l><\/$l>$h$eMIXCLOUD\"><$l$fmixcloud\"$g$c400px\"><$l$g$a100%\">$d$k\/\/www.mixcloud.com\/widget\/$z\/?feed=http%3A%2F%2Fwww.mixcloud.com%2F{@id}%2F&amp;embed_type=widget_standard\"$g$b\/><\/$l><\/$l>$h$eMLB\"><$l$fmlb\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/m.mlb.com\/shared\/video\/embed\/embed.html?content_id={@id}&amp;width=640&amp;height=360\"$g$b\/><\/$l><\/$l>$h$eMRCTV\"><$l$fmrctv\"$g$c640px\"><$l$g$a56.25%\">$d$khttps:\/\/www.mrctv.org\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eMSNBC\"><$l$fmsnbc\"$g$c635px\"><$l$g$a69.291339%\">$d$k\/\/player.theplatform.com\/p\/2E2eJC\/EmbeddedOffSite?guid={@id}\"$g$b\/><\/$l><\/$l>$h$eNATGEOCHANNEL\"><$l$fnatgeochannel\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/channel.nationalgeographic.com\/{@id}\/embed\/\"$g$b\/><\/$l><\/$l>$h$eNATGEOVIDEO\"><$l$fnatgeovideo\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/player.d.nationalgeographic.com\/players\/ngsvideo\/share\/?guid={@id}\"$g$b\/><\/$l><\/$l>$h$eNBCNEWS\"><$l$fnbcnews\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.nbcnews.com\/widget\/video-embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eNBCSPORTS\"><$l$fnbcsports\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/vplayer.nbcsports.com\/p\/BxmELC\/nbcsports_embed\/select\/media\/{@id}?parentUrl=\"$g$b\/><\/$l><\/$l>$h$eNHL\"><$l$fnhl\"$g$c640px\"><$l$g$a56.25%\">$d$g$b><$t$wsrc\"><$u><$r$q@c or@t\">\/\/www.nhl.com\/video\/embed<xsl:if$q@t\">\/t-$j@t\"\/><\/xsl:if><xsl:if$q@c\">\/c-$j@c\"\/><\/xsl:if>?autostart=false<\/$r><$p>\/\/video.nhl.com\/videocenter\/embed?playlist=$j@id\"\/><\/$p><\/$u><\/$t><\/$z><\/$l><\/$l>$h$eNPR\"><$z$fnpr\"$m\"$sno\"$k\/\/www.npr.org\/player\/embed\/{@i}\/{@m}\"$gborder:0;height:228px;max-width:800px;width:100%\"\/>$h$eNYTIMES\"><$l$fnytimes\"$g$c585px\"><$l$g$a68.376068%\">$d$k\/\/graphics8.nytimes.com\/video\/players\/offsite\/index.html?videoId={@id}\"$g$b\/><\/$l><\/$l>$h$eODDSHOT\"><$l$foddshot\"$g$c640px\"><$l$g$a56.25%\">$d$khttps:\/\/oddshot.tv\/s\/{@id}\/embed\"$g$b\/><\/$l><\/$l>$h$ePASTEBIN\"><$z$fpastebin\"$m\"$s\"$k\/\/pastebin.com\/embed_$z.php?i={@id}\"$gborder:0;height:300px;resize:vertical;width:100%\"\/>$h$ePINTEREST\"><$z$fpinterest\"$m\" onload=\"$i$sno\"$khttps:\/\/s9e.github.io\/$z\/pinterest.min.html#{@id}\"><$t$wstyle\">border:0;height:360px;max-width:<$u><$r$qcontains(@id,'\/')\">730<\/$r><$p>345<\/$p><\/$u>px;width:100%<\/$t><\/$z>$h$ePLAYSTV\"><$l$fplaystv\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/plays.tv\/embeds\/{@id}\"$g$b\/><\/$l><\/$l>$h$ePODBEAN\"><$z$fpodbean\"$m\"$sno\"$k\/\/www.podbean.com\/media\/player\/{@id}\"$gborder:0;height:100px;max-width:900px;width:100%\"\/>$h$ePREZI\"><$l$fprezi\"$g$c550px\"><$l$g$a72.727273%\">$d$k\/\/prezi.com\/embed\/{@id}\/\"$g$b\/><\/$l><\/$l>$h$eQUOTE\"><blockquote>$x<\/blockquote>$h$eREDDIT\"><$z$freddit\"$m\" onload=\"$i$sno\"$khttps:\/\/s9e.github.io\/$z\/reddit.min.html#{@path}\"$gborder:0;height:165px;max-width:800px;width:100%\"\/>$h$eRUTUBE\"><$l$frutube\"$g$c720px\"><$l$g$a56.25%\">$d$k\/\/rutube.ru\/play\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eSCRIBD\"><$z$fscribd\"$m\"$sno\"$khttps:\/\/www.scribd.com\/embeds\/{@id}\/content?view_mode=scroll&amp;show_recommendations=false\"$gborder:0;height:500px;resize:vertical;width:100%\"\/>$h$eSLIDESHARE\"><$l$fslideshare\"$g$c427px\"><$l$g$a83.372365%\">$d$k\/\/www.slideshare.net\/slideshow\/embed_code\/{@id}\"$g$b\/><\/$l><\/$l>$h$eSOUNDCLOUD\"><$z$fsoundcloud\"$m\"$sno\"><$t$wsrc\">https:\/\/w.soundcloud.com\/player\/?url=<$u><$r$q@playlist_id\">https%3A\/\/api.soundcloud.com\/playlists\/$j@playlist_id\"\/><\/$r><$r$q@track_id\">https%3A\/\/api.soundcloud.com\/tracks\/$j@track_id\"\/>&amp;secret_token=$j@secret_token\"\/><\/$r><$p><xsl:if$qnot(contains(@id,':\/\/'))\">https%3A\/\/soundcloud.com\/<\/xsl:if>$j@id\"\/><\/$p><\/$u><\/$t><$t$wstyle\">border:0;height:<$u><$r$q@playlist_id or contains(@id,'\/sets\/')\">450<\/$r><$p>166<\/$p><\/$u>px;max-width:900px;width:100%<\/$t><\/$z>$h$eSPORTSNET\"><$l$fsportsnet\"$g$c640px\"><$l$g$a56.25%\">$d$khttps:\/\/images.rogersdigitalmedia.com\/video_service.php?videoId={@id}&amp;playerKey=AQ~~,AAAAAGWRwLc~,cRCmKE8Utf7OFWP38XQcokFZ80fR-u_y&amp;autoStart=false&amp;width=100%25&amp;height=100%25\"$g$b\/><\/$l><\/$l>$h$eSPOTIFY\"><$l$fspotify\"$g$c400px\"><$l$g$a120%\">$d$g$b><$t$wsrc\">https:\/\/embed.spotify.com\/?view=coverart&amp;uri=<$u><$r$q@uri\">$j@uri\"\/><\/$r><$p>spotify:$jtranslate(@path,'\/',':')\"\/><\/$p><\/$u><\/$t><\/$z><\/$l><\/$l>$h$eSTEAMSTORE\"><$z$fsteamstore\"$m\"$sno\"$k\/\/store.steampowered.com\/widget\/{@id}\"$gborder:0;height:190px;max-width:900px;width:100%\"\/>$h$eSTITCHER\"><$z$fstitcher\"$m\"$sno\"$k\/\/app.stitcher.com\/splayer\/f\/{@fid}\/{@eid}\"$gborder:0;height:150px;max-width:900px;width:100%\"\/>$h$eSTRAWPOLL\"><$l$fstrawpoll\"$g$c640px\"><$l$g$a56.25%\"><$z$m\"$s\"$k\/\/www.strawpoll.me\/embed_1\/{@id}\"$g$b\/><\/$l><\/$l>$h$eSTREAMABLE\"><$l$fstreamable\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/streamable.com\/e\/{@id}\"$g$b\/><\/$l><\/$l>$h$eTEAMCOCO\"><$l$fteamcoco\"$g$c640px\"><$l$g$a64.84375%\">$d$k\/\/teamcoco.com\/embed\/v\/{@id}\"$g$b\/><\/$l><\/$l>$h$eTED\"><$l$fted\"$g$c640px\"><$l$g$a56.25%\">$d$g$b><$t$wsrc\">\/\/embed.ted.com\/$j@id\"\/><xsl:if$qnot(contains(@id,'.html'))\">.html<\/xsl:if><\/$t><\/$z><\/$l><\/$l>$h$eTHEATLANTIC\"><$l$ftheatlantic\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.theatlantic.com\/video\/$z\/{@id}\/\"$g$b\/><\/$l><\/$l>$h$eTHEGUARDIAN\"><$l$ftheguardian\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/embed.theguardian.com\/embed\/video\/{@id}\"$g$b\/><\/$l><\/$l>$h$eTHEONION\"><$l$ftheonion\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.theonion.com\/video_embed\/?id={@id}\"$g$b\/><\/$l><\/$l>$h$eTINYPIC\"><$l$ftinypic\"$g$c640px\"><$l$g$a60.9375%;padding-bottom:calc(56.25% + 30px)\"><object data=\"\/\/tinypic.com\/player.swf?file={@id}&amp;s={@s}\"$g$o type=\"$v$y\">$n<\/object><\/$l><\/$l>$h$eTMZ\"><$l$ftmz\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.kaltura.com\/index.php\/kwidget\/cache_st\/133592691\/wid\/_591531\/partner_id\/591531\/uiconf_id\/9071262\/entry_id\/{@id}\"$g$b\/><\/$l><\/$l>$h$eTRAILERADDICT\"><$l$ftraileraddict\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/v.traileraddict.com\/{@id}\"$g$b\/><\/$l><\/$l>$h$eTUMBLR\"><$z$ftumblr\"$m\" onload=\"$i$sno\"$khttps:\/\/s9e.github.io\/$z\/tumblr.min.html#{@key}\/{@id}\"$gborder:0;height:180px;max-width:520px;width:100%\"\/>$h$eTWITCH\"><$l$ftwitch\"$g$c640px\"><$l$g$a56.25%\">$d$g$b><$t$wsrc\"><$u><$r$q@clip_id\">\/\/clips.twitch.tv\/embed?autoplay=false&amp;clip=<xsl:if$q@channel\">$j@channel\"\/>\/<\/xsl:if>$j@clip_id\"\/><\/$r><$p>\/\/player.twitch.tv\/?autoplay=false&amp;<$u><$r$q@video_id\">video=v$j@video_id\"\/><\/$r><$p>channel=$j@channel\"\/><\/$p><\/$u><xsl:if$q@t\">&amp;time=$j@t\"\/><\/xsl:if><\/$p><\/$u><\/$t><\/$z><\/$l><\/$l>$h$eTWITTER\"><$z$ftwitter\"$m\" onload=\"$i$sno\"$khttps:\/\/s9e.github.io\/$z\/twitter.min.html#{@id}\"$gbackground:url(https:\/\/abs.twimg.com\/favicons\/favicon.ico) no-repeat 50% 50%;border:0;height:186px;max-width:500px;width:100%\"\/>$h$eURL\"><a href=\"{@url}\" target=\"_blank\">$x<\/a>$h$eUSTREAM\"><$l$fustream\"$g$c640px\"><$l$g$a56.25%\"><$u><$r$q@vid\">$d$k\/\/www.ustream.tv\/embed\/recorded\/{@vid}?html5ui\"$g$b\/><\/$r><$p>$d$k\/\/www.ustream.tv\/embed\/{@cid}?html5ui\"$g$b\/><\/$p><\/$u><\/$l><\/$l>$h$eVBOX7\"><$l$fvbox7\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/vbox7.com\/emb\/external.php?vid={@id}\"$g$b\/><\/$l><\/$l>$h$eVEOH\"><$l$fveoh\"$g$c640px\"><$l$g$a62.5%;padding-bottom:calc(56.25% + 40px)\"><object data=\"\/\/www.veoh.com\/swf\/webplayer\/WebPlayer.swf?version=AFrontend.5.7.0.1509&amp;permalinkId=v{@id}&amp;player=videodetailsembedded&amp;videoAutoPlay=0&amp;id=anonymous\"$g$o type=\"$v$y\">$n<\/object><\/$l><\/$l>$h$eVEVO\"><$l$fvevo\"$g$c575px\"><$l$g$a56.347826%\">$d$k\/\/cache.vevo.com\/m\/html\/embed.html?video={@id}\"$g$b\/><\/$l><\/$l>$h$eVIAGAME\"><$l$fviagame\"$g$c640px\"><$l$g$a61.25%\">$d$k\/\/www.viagame.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eVIDEODETECTIVE\"><$l$fvideodetective\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.videodetective.com\/embed\/video\/?options=false&amp;autostart=false&amp;playlist=none&amp;publishedid={@id}\"$g$b\/><\/$l><\/$l>$h$eVIDEOMEGA\"><$l$fvideomega\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/videomega.tv\/$z.php?ref={@id}\"$g$b\/><\/$l><\/$l>$h$eVIDME\"><$l$fvidme\"$g$c640px\"><$l$g$a56.25%\">$d$khttps:\/\/vid.me\/e\/{@id}\"$g$b\/><\/$l><\/$l>$h$eVIMEO\"><$l$fvimeo\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/player.vimeo.com\/video\/{@id}\"$g$b\/><\/$l><\/$l>$h$eVINE\"><$l$fvine\"$g$c480px\"><$l$g$a100%\">$d$khttps:\/\/vine.co\/v\/{@id}\/embed\/simple?audio=1\"$g$b\/><\/$l><\/$l>$h$eVK\"><$l$fvk\"$g$c607px\"><$l$g$a59.308072%\">$d$k\/\/vk.com\/video_ext.php?oid={@oid}&amp;id={@vid}&amp;hash={@hash}&amp;hd=1\"$g$b\/><\/$l><\/$l>$h$eVOCAROO\"><$l$fvocaroo\"$g$c148px\"><$l$g$a29.72973%\"><object data=\"\/\/vocaroo.com\/player.swf?playMediaID={@id}&amp;autoplay=0\"$g$o type=\"$v$y\">$n<\/object><\/$l><\/$l>$h$eVOX\"><$l$fvox\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/player.ooyala.com\/$z.html#pbid=a637d53c5c0a43c7bf4e342886b9d8b0&amp;ec={@id}\"$g$b\/><\/$l><\/$l>$h$eWASHINGTONPOST\"><$l$fwashingtonpost\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.washingtonpost.com\/video\/c\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eWSHH\"><$l$fwshh\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/www.worldstarhiphop.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eWSJ\"><$l$fwsj\"$g$c512px\"><$l$g$a56.25%\">$d$k\/\/video-api.wsj.com\/api-video\/player\/$z.html?guid={@id}\"$g$b\/><\/$l><\/$l>$h$eXBOXCLIPS\"><$l$fxboxclips\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/xboxclips.com\/{@user}\/{@id}\/embed\"$g$b\/><\/$l><\/$l>$h$eXBOXDVR\"><$l$fxboxdvr\"$g$c640px\"><$l$g$a56.25%\">$d$k\/\/xboxdvr.com\/gamer\/{@user}\/video\/{@id}\/embed\"$g$b\/><\/$l><\/$l>$h$eYAHOOSCREEN\"><$l$fyahooscreen\"$g$c640px\"><$l$g$a56.25%\">$d$khttps:\/\/screen.yahoo.com\/{@id}.html?format=embed\"$g$b\/><\/$l><\/$l>$h$eYOUKU\"><$l$fyouku\"$g$c640px\"><$l$g$a62.5%;padding-bottom:calc(56.25% + 40px)\">$d$khttps:\/\/players.youku.com\/embed\/{@id}\"$g$b\/><\/$l><\/$l>$h$eYOUTUBE\"><$l$fyoutube\"$g$c640px\"><$l$g$a56.25%\">$d$gbackground:url(https:\/\/i.ytimg.com\/vi\/{@id}\/hqdefault.jpg) 50% 50% \/ cover;$b><$t$wsrc\">https:\/\/www.youtube.com\/embed\/$j@id\"\/>?controls=2<xsl:if$q@list\">&amp;list=$j@list\"\/><\/xsl:if><xsl:if$q@t or@m\">&amp;start=<$u><$r$q@t\">$j@t\"\/><\/$r><$r$q@h\">$j@h*3600+@m*60+@s\"\/><\/$r><$p>$j@m*60+@s\"\/><\/$p><\/$u><\/xsl:if><\/$t><\/$z><\/$l><\/$l>$h$eZIPPYSHARE\"><object$fzippyshare\" data=\"\/\/api.zippyshare.com\/api\/player.swf\"$gheight:80px;max-width:900px;width:100%\" type=\"$v$y\">$n<param$wflashvars\" value=\"file={@file}&amp;server={@server}&amp;autostart=false\"\/><\/object>$h$ebr\"><br\/>$h$ee|i|s\"\/><\/xsl:stylesheet>".replace(/\$[a-z]/g,function(k){return{"$a":"display:block;overflow:hidden;position:relative;padding-bottom:","$b":"border:0;height:100%;left:0;position:absolute;width:100%\"","$c":"display:inline-block;width:100%;max-width:","$d":"<iframe allowfullscreen=\"\" scrolling=\"no\"","$e":"<xsl:template match=\"","$f":" data-s9e-mediaembed=\"","$g":" style=\"","$h":"<\/xsl:template>","$i":"var a=Math.random();window.addEventListener('message',function(b){{if(b.data.id==a)style.height=b.data.height+'px'}});contentWindow.postMessage('s9e:'+a,'https:\/\/s9e.github.io')\"","$j":"<xsl:value-of select=\"","$k":" src=\"","$l":"span","$m":" allowfullscreen=\"","$n":"<param name=\"allowfullscreen\" value=\"true\"\/>","$o":"height:100%;left:0;position:absolute;width:100%\"","$p":"xsl:otherwise","$q":" test=\"","$r":"xsl:when","$s":" scrolling=\"","$t":"xsl:attribute","$u":"xsl:choose","$v":"application\/x-shockwave-flash\"","$w":" name=\"","$x":"<xsl:apply-templates\/>","$y":" typemustmatch=\"","$z":"iframe"}[k]});
/**
* @param  {!string} str
* @return {!string}
*/
function html_entity_decode(str)
{
	var b = document.createElement('b');

	html_entity_decode = function (str)
	{
		// We escape left brackets so that we don't inadvertently evaluate some nasty HTML such as
		// <img src=... onload=evil() />
		b.innerHTML = str.replace(/</g, '&lt;');

		return b.textContent;
	}

	return html_entity_decode(str);
}

/**
* @param  {!string} str
* @return {!string}
*/
function htmlspecialchars_compat(str)
{
	var t = {
		'<' : '&lt;',
		'>' : '&gt;',
		'&' : '&amp;',
		'"' : '&quot;'
	};
	return str.replace(
		/[<>&"]/g,
		/**
		* @param {!string} c
		*/
		function(c)
		{
			return t[c];
		}
	);
}

/**
* @param  {!string} str
* @return {!string}
*/
function htmlspecialchars_noquotes(str)
{
	var t = {
		'<' : '&lt;',
		'>' : '&gt;',
		'&' : '&amp;'
	};
	return str.replace(
		/[<>&]/g,
		/**
		* @param {!string} c
		*/
		function(c)
		{
			return t[c];
		}
	);
}

/**
* @return {!boolean}
*/
function returnFalse()
{
	return false;
}

/**
* @return {!boolean}
*/
function returnTrue()
{
	return true;
}
/**
* @param  {!string} str
* @return {!string}
*/
function rawurlencode(str)
{
	return encodeURIComponent(str).replace(
		/[!'()*]/g,
		/**
		* @param {!string} c
		*/
		function(c)
		{
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		}
	);
}

/**
* IMPORTANT NOTE: those filters are only meant to catch bad input and honest mistakes. They don't
*                 match their PHP equivalent exactly and may let unwanted values through. Their
*                 result should always be checked by PHP filters
*
* @const
*/
var BuiltInFilters =
{
	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterAlnum: function(attrValue)
	{
		return /^[0-9A-Za-z]+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterColor: function(attrValue)
	{
		return /^(?:#[0-9a-f]{3,6}|rgb\(\d{1,3}, *\d{1,3}, *\d{1,3}\)|[a-z]+)$/i.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterEmail: function(attrValue)
	{
		return /^[-\w.+]+@[-\w.]+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {!boolean}
	*/
	filterFalse: function(attrValue)
	{
		return false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterFloat: function(attrValue)
	{
		return /^(?:0|-?[1-9]\d*)(?:\.\d+)?(?:e[1-9]\d*)?$/i.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*}        attrValue Original value
	* @param  {!Object}  map       Hash map
	* @param  {!boolean} strict    Whether this map is strict (values with no match are invalid)
	* @return {*}                  Filtered value, or FALSE if invalid
	*/
	filterHashmap: function(attrValue, map, strict)
	{
		if (attrValue in map)
		{
			return map[attrValue];
		}

		return (strict) ? false : attrValue;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIdentifier: function(attrValue)
	{
		return /^[-\w]+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterInt: function(attrValue)
	{
		return /^(?:0|-?[1-9]\d*)$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIp: function(attrValue)
	{
		if (/^[\d.]+$/.test(attrValue))
		{
			return BuiltInFilters.filterIpv4(attrValue);
		}

		if (/^[\da-f:]+$/i.test(attrValue))
		{
			return BuiltInFilters.filterIpv6(attrValue);
		}

		return false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIpport: function(attrValue)
	{
		var m, ip;

		if (m = /^\[([\da-f:]+)(\]:[1-9]\d*)$/i.exec(attrValue))
		{
			ip = BuiltInFilters.filterIpv6(m[1]);

			if (ip === false)
			{
				return false;
			}

			return '[' + ip + m[2];
		}

		if (m = /^([\d.]+)(:[1-9]\d*)$/.exec(attrValue))
		{
			ip = BuiltInFilters.filterIpv4(m[1]);

			if (ip === false)
			{
				return false;
			}

			return ip + m[2];
		}

		return false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIpv4: function(attrValue)
	{
		if (!/^\d+\.\d+\.\d+\.\d+$/.test(attrValue))
		{
			return false;
		}

		var i = 4, p = attrValue.split('.');
		while (--i >= 0)
		{
			// NOTE: ext/filter doesn't support octal notation
			if (p[i].charAt(0) === '0' || p[i] > 255)
			{
				return false;
			}
		}

		return attrValue;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIpv6: function(attrValue)
	{
		return /^(\d*:){2,7}\d+(?:\.\d+\.\d+\.\d+)?$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @param  {!Array.<!Array>}  map
	* @return {*}
	*/
	filterMap: function(attrValue, map)
	{
		var i = -1, cnt = map.length;
		while (++i < cnt)
		{
			if (map[i][0].test(attrValue))
			{
				return map[i][1];
			}
		}

		return attrValue;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterNumber: function(attrValue)
	{
		return /^\d+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*}       attrValue
	* @param  {!number} min
	* @param  {!number} max
	* @param  {Logger}  logger
	* @return {!number|boolean}
	*/
	filterRange: function(attrValue, min, max, logger)
	{
		if (!/^(?:0|-?[1-9]\d*)$/.test(attrValue))
		{
			return false;
		}

		attrValue = parseInt(attrValue, 10);

		if (attrValue < min)
		{
			if (logger)
			{
				logger.warn(
					'Value outside of range, adjusted up to min value',
					{
						'attrValue' : attrValue,
						'min'       : min,
						'max'       : max
					}
				);
			}

			return min;
		}

		if (attrValue > max)
		{
			if (logger)
			{
				logger.warn(
					'Value outside of range, adjusted down to max value',
					{
						'attrValue' : attrValue,
						'min'       : min,
						'max'       : max
					}
				);
			}

			return max;
		}

		return attrValue;
	},

	/**
	* @param  {*} attrValue
	* @param  {!RegExp} regexp
	* @return {*}
	*/
	filterRegexp: function(attrValue, regexp)
	{
		return regexp.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterSimpletext: function(attrValue)
	{
		return /^[-\w+., ]+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterUint: function(attrValue)
	{
		return /^(?:0|[1-9]\d*)$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @param  {!Object} urlConfig
	* @param  {Logger} logger
	* @return {*}
	*/
	filterUrl: function(attrValue, urlConfig, logger)
	{
		/**
		* Trim the URL to conform with HTML5 then parse it
		* @link http://dev.w3.org/html5/spec/links.html#attr-hyperlink-href
		*/
		var p = BuiltInFilters.parseUrl(attrValue.replace(/^\s+/, '').replace(/\s+$/, ''));

		var error = BuiltInFilters.validateUrl(urlConfig, p);
		if (error)
		{
			if (logger)
			{
				p['attrValue'] = attrValue;
				logger.err(error, p);
			}

			return false;
		}

		return BuiltInFilters.rebuildUrl(urlConfig, p);
	},

	/**
	* Parse a URL and return its components
	*
	* Similar to PHP's own parse_url() except that all parts are always returned
	*
	* @param  {!string} url Original URL
	* @return {!Object}
	*/
	parseUrl: function(url)
	{
		var regexp = /^(?:([a-z][-+.\w]*):)?(?:\/\/(?:([^:\/?#]*)(?::([^\/?#]*)?)?@)?(?:(\[[a-f\d:]+\]|[^:\/?#]+)(?::(\d*))?)?(?![^\/?#]))?([^?#]*)(\?[^#]*)?(#.*)?$/i;

		// NOTE: this regexp always matches because of the last three captures
		var m = regexp['exec'](url),
			parts = {},
			tokens = ['scheme', 'user', 'pass', 'host', 'port', 'path', 'query', 'fragment'];
		tokens.forEach(
			function(name, i)
			{
				parts[name] = (m[i + 1] > '') ? m[i + 1] : '';
			}
		);

		/**
		* @link http://tools.ietf.org/html/rfc3986#section-3.1
		*
		* 'An implementation should accept uppercase letters as equivalent to lowercase in
		* scheme names (e.g., allow "HTTP" as well as "http") for the sake of robustness but
		* should only produce lowercase scheme names for consistency.'
		*/
		parts['scheme'] = parts['scheme'].toLowerCase();

		/**
		* Normalize the domain label separators and remove trailing dots
		* @link http://url.spec.whatwg.org/#domain-label-separators
		*/
		parts['host'] = parts['host'].replace(/[\u3002\uff0e\uff61]/g, '.').replace(/\.+$/g, '');

		// Test whether host has non-ASCII characters and punycode it if possible
		if (/[^\x00-\x7F]/.test(parts['host']) && typeof punycode !== 'undefined')
		{
			parts['host'] = punycode.toASCII(parts['host']);
		}

		return parts;
	},

	/**
	* Rebuild a parsed URL
	*
	* @param  {!Object} urlConfig
	* @param  {!Object} p
	* @return {!string}
	*/
	rebuildUrl: function(urlConfig, p)
	{
		var url = '';
		if (p['scheme'] !== '')
		{
			url += p['scheme'] + ':';
		}
		if (p['host'] === '')
		{
			// Allow the file: scheme to not have a host and ensure it starts with slashes
			if (p['scheme'] === 'file')
			{
				url += '//';
			}
		}
		else
		{
			url += '//';

			// Add the credentials if applicable
			if (p['user'] !== '')
			{
				// Reencode the credentials in case there are invalid chars in them, or suspicious
				// characters such as : or @ that could confuse a browser into connecting to the
				// wrong host (or at least, to a host that is different than the one we thought)
				url += rawurlencode(decodeURIComponent(p['user']));

				if (p['pass'] !== '')
				{
					url += ':' + rawurlencode(decodeURIComponent(p['pass']));
				}

				url += '@';
			}

			url += p['host'];

			// Append the port number (note that as per the regexp it can only contain digits)
			if (p['port'] !== '')
			{
				url += ':' + p['port'];
			}
		}

		// Build the path, including the query and fragment parts
		var path = p['path'] + p['query'] + p['fragment'];

		/**
		* "For consistency, URI producers and normalizers should use uppercase hexadecimal digits
		* for all percent- encodings."
		*
		* @link http://tools.ietf.org/html/rfc3986#section-2.1
		*/
		path = path.replace(
			/%.?[a-f]/,
			function (m)
			{
				return m[0].toUpperCase();
			},
			path
		);

		// Append the sanitized path to the URL
		url += BuiltInFilters.sanitizeUrl(path);

		// Replace the first colon if there's no scheme and it could potentially be interpreted as
		// the scheme separator
		if (!p['scheme'])
		{
			url = url.replace(/^([^\/]*):/, '$1%3A', url);
		}

		return url;
	},

	/**
	* Sanitize a URL for safe use regardless of context
	*
	* This method URL-encodes some sensitive characters in case someone would want to use the URL in
	* some JavaScript thingy, or in CSS. We also encode characters that are not allowed in the path
	* of a URL as defined in RFC 3986 appendix A, including percent signs that are not immediately
	* followed by two hex digits.
	*
	* " and ' to prevent breaking out of quotes (JavaScript or otherwise)
	* ( and ) to prevent the use of functions in JavaScript (eval()) or CSS (expression())
	* < and > to prevent breaking out of <script>
	* \r and \n because they're illegal in JavaScript
	* [ and ] because the W3 validator rejects them and they "should" be escaped as per RFC 3986
	* Non-ASCII characters as per RFC 3986
	* Control codes and spaces, as per RFC 3986
	*
	* @link http://sla.ckers.org/forum/read.php?2,51478
	* @link http://timelessrepo.com/json-isnt-a-javascript-subset
	* @link http://www.ietf.org/rfc/rfc3986.txt
	* @link http://stackoverflow.com/a/1547922
	* @link http://tools.ietf.org/html/rfc3986#appendix-A
	*
	* @param  {!string} url Original URL
	* @return {!string}     Sanitized URL
	*/
	sanitizeUrl: function(url)
	{
		return url.replace(/[^\u0020-\u007E]+/g, encodeURIComponent).replace(/%(?![0-9A-Fa-f]{2})|[^!#-&*-;=?-Z_a-z~]/g, escape);
	},

	/**
	* Validate a parsed URL
	*
	* @param  {!Object} urlConfig
	* @param  {!Object} p
	* @return {string|undefined}
	*/
	validateUrl: function(urlConfig, p)
	{
		if (p['scheme'] !== '' && !urlConfig.allowedSchemes.test(p['scheme']))
		{
			return 'URL scheme is not allowed';
		}

		if (p['host'] === '')
		{
			// Reject malformed URLs such as http:///example.org but allow schemeless paths
			if (p['scheme'] !== 'file' && p['scheme'] !== '')
			{
				return 'Missing host';
			}
		}
		else
		{
			/**
			* Test whether the host is valid
			* @link http://tools.ietf.org/html/rfc1035#section-2.3.1
			* @link http://tools.ietf.org/html/rfc1123#section-2
			*/
			var regexp = /^(?!-)[-a-z0-9]{0,62}[a-z0-9](?:\.(?!-)[-a-z0-9]{0,62}[a-z0-9])*$/i;
			if (!regexp.test(p['host']))
			{
				// If the host invalid, retest as an IPv4 and IPv6 address (IPv6 in brackets)
				if (!BuiltInFilters.filterIpv4(p['host'])
				 && !BuiltInFilters.filterIpv6(p['host'].replace(/^\[(.*)\]$/, '$1', p['host'])))
				{
					return 'URL host is invalid';
				}
			}

			if ((urlConfig.disallowedHosts && urlConfig.disallowedHosts.test(p['host']))
			 || (urlConfig.restrictedHosts && !urlConfig.restrictedHosts.test(p['host'])))
			{
				return 'URL host is not allowed';
			}
		}
	}
}
/**@constructor*/function Logger(){}Logger.prototype={add:/**
* Add a log entry
*
* @param  {!string}  type    Log type
* @param  {!string}  msg     Log message
* @param  {!Object=} context Log context
*/
function(type, msg, context){},clear:/**
* Clear the log
*/
function(){},setAttribute:/**
* Record the name of the attribute being processed
*
* @param  {!string} attrName
*/
function(attrName){},setTag:/**
* Record the tag being processed
*
* @param  {!Tag} tag
*/
function(tag){},unsetAttribute:/**
* Unset the name of the attribute being processed
*/
function(){},unsetTag:/**
* Unset the tag being processed
*/
function(){},debug:/**
* Add a "debug" type log entry
*
* @param  {!string}  msg     Log message
* @param  {!Object=} context Log context
*/
function(msg, context){},err:/**
* Add an "err" type log entry
*
* @param  {!string}  msg     Log message
* @param  {!Object=} context Log context
*/
function(msg, context){},info:/**
* Add an "info" type log entry
*
* @param  {!string}  msg     Log message
* @param  {!Object=} context Log context
*/
function(msg, context){},warn:/**
* Add a "warn" type log entry
*
* @param  {!string}  msg     Log message
* @param  {!Object=} context Log context
*/
function(msg, context){}}
/**
* @constructor
*
* @param {!number} type     Tag's type
* @param {!string} name     Name of the tag
* @param {!number} pos      Position of the tag in the text
* @param {!number} len      Length of text consumed by the tag
* @param {number}  priority This tag's sorting tiebreaker
*/
function Tag(type, name, pos, len, priority)
{
	this.type = +type;
	this.name = name;
	this.pos  = +pos;
	this.len  = +len;
	if (typeof priority !== 'undefined')
	{
		this.sortPriority = +priority;
	}

	this.attributes = {};
	this.cascade    = [];

	// Invalidate this tag now if any value is not a number, they could wreck
	// havoc in other parts of the program
	if (isNaN(type + pos + len))
	{
		this.invalidate();
	}
}

/** @const */
Tag.START_TAG = 1;

/** @const */
Tag.END_TAG = 2;

/** @const */
Tag.SELF_CLOSING_TAG = 3;

/**
* @type {!Object} Dictionary of attributes
*/
Tag.prototype.attributes;

/**
* @type {!Array.<!Tag>} List of tags that are invalidated when this tag is invalidated
*/
Tag.prototype.cascade;

/**
* @type {Tag} End tag that unconditionally ends this start tag
*/
Tag.prototype.endTag;

/**
* @type {!boolean} Whether this tag is be invalid
*/
Tag.prototype.invalid = false;

/**
* @type {!number} Length of text consumed by this tag
*/
Tag.prototype.len;

/**
* @type {!string} Name of this tag
*/
Tag.prototype.name;

/**
* @type {!number} Position of this tag in the text
*/
Tag.prototype.pos;

/**
* @type {!number} Tiebreaker used when sorting identical tags
*/
Tag.prototype.sortPriority;

/**
* @type {Tag} Start tag that is unconditionally closed this end tag
*/
Tag.prototype.startTag;

/**
* @type {!number} Tag type
*/
Tag.prototype.type;

/**
* Add a set of flags to this tag's
*
* @param {!number} flags
*/
Tag.prototype.addFlags = function(flags)
{
	this.flags |= flags;
};

/**
* Set given tag to be invalidated if this tag is invalidated
*
* @param {!Tag} tag
*/
Tag.prototype.cascadeInvalidationTo = function(tag)
{
	this.cascade.push(tag);

	// If this tag is already invalid, cascade it now
	if (this.invalid)
	{
		tag.invalidate();
	}
};

/**
* Invalidate this tag, as well as tags bound to this tag
*/
Tag.prototype.invalidate = function()
{
	// If this tag is already invalid, we can return now. This prevent infinite loops
	if (this.invalid)
	{
		return;
	}

	this.invalid = true;

	this.cascade.forEach(
		/**
		* @param {!Tag} tag
		*/
		function(tag)
		{
			tag.invalidate();
		}
	);
}

/**
* Pair this tag with given tag
*
* @param {!Tag} tag
*/
Tag.prototype.pairWith = function(tag)
{
	if (this.name === tag.name)
	{
		if (this.type === Tag.START_TAG
		 && tag.type  === Tag.END_TAG
		 && tag.pos   >=  this.pos)
		{
			this.endTag  = tag;
			tag.startTag = this;

			this.cascadeInvalidationTo(tag);
		}
		else if (this.type === Tag.END_TAG
		      && tag.type  === Tag.START_TAG
		      && tag.pos   <=  this.pos)
		{
			this.startTag = tag;
			tag.endTag    = this;
		}
	}
}

/**
* Remove a set of flags from this tag's
*
* @param {!number} flags
*/
Tag.prototype.removeFlags = function(flags)
{
	this.flags &= ~flags;
};

/**
* Set the bitfield of boolean rules that apply to this tag
*
* @param  {!number} flags Bitfield of boolean rules that apply to this tag
*/
Tag.prototype.setFlags = function(flags)
{
	this.flags = flags;
}

/**
* Set this tag's tiebreaker
*
* @param  {!number} sortPriority
*/
Tag.prototype.setSortPriority = function(sortPriority)
{
	this.sortPriority = sortPriority;
}

//==========================================================================
// Getters
//==========================================================================

/**
* Return this tag's attributes
*
* @return {!Object}
*/
Tag.prototype.getAttributes = function()
{
	var attributes = {};
	for (var attrName in this.attributes)
	{
		attributes[attrName] = this.attributes[attrName];
	}

	return attributes;
}

/**
* Return this tag's end tag
*
* @return {Tag} This tag's end tag
*/
Tag.prototype.getEndTag = function()
{
	return this.endTag;
}

/**
* Return the bitfield of boolean rules that apply to this tag
*
* @return {!number}
*/
Tag.prototype.getFlags = function()
{
	return this.flags;
}

/**
* Return the length of text consumed by this tag
*
* @return {!number}
*/
Tag.prototype.getLen = function()
{
	return this.len;
}

/**
* Return this tag's name
*
* @return {!string}
*/
Tag.prototype.getName = function()
{
	return this.name;
}

/**
* Return this tag's position
*
* @return {!number}
*/
Tag.prototype.getPos = function()
{
	return this.pos;
}

/**
* Return this tag's tiebreaker
*
* @return {!number}
*/
Tag.prototype.getSortPriority = function()
{
	return this.sortPriority;
}

/**
* Return this tag's start tag
*
* @return {Tag} This tag's start tag
*/
Tag.prototype.getStartTag = function()
{
	return this.startTag;
}

/**
* Return this tag's type
*
* @return {!number}
*/
Tag.prototype.getType = function()
{
	return this.type;
}

//==========================================================================
// Tag's status
//==========================================================================

/**
* Test whether this tag can close given start tag
*
* @param  {!Tag} startTag
* @return {!boolean}
*/
Tag.prototype.canClose = function(startTag)
{
	if (this.invalid
	 || this.name !== startTag.name
	 || startTag.type !== Tag.START_TAG
	 || this.type !== Tag.END_TAG
	 || this.pos < startTag.pos
	 || (this.startTag && this.startTag !== startTag)
	 || (startTag.endTag && startTag.endTag !== this))
	{
		return false;
	}

	return true;
}

/**
* Test whether this tag is a br tag
*
* @return {!boolean}
*/
Tag.prototype.isBrTag = function()
{
	return (this.name === 'br');
}

/**
* Test whether this tag is an end tag (self-closing tags inclusive)
*
* @return {!boolean}
*/
Tag.prototype.isEndTag = function()
{
	return !!(this.type & Tag.END_TAG);
}

/**
* Test whether this tag is an ignore tag
*
* @return {!boolean}
*/
Tag.prototype.isIgnoreTag = function()
{
	return (this.name === 'i');
}

/**
* Test whether this tag is invalid
*
* @return {!boolean}
*/
Tag.prototype.isInvalid = function()
{
	return this.invalid;
}

/**
* Test whether this tag represents a paragraph break
*
* @return {!boolean}
*/
Tag.prototype.isParagraphBreak = function()
{
	return (this.name === 'pb');
}

/**
* Test whether this tag is a self-closing tag
*
* @return {!boolean}
*/
Tag.prototype.isSelfClosingTag = function()
{
	return (this.type === Tag.SELF_CLOSING_TAG);
}

/**
* Test whether this tag is a special tag: "br", "i", "pb" or "v"
*
* @return {!boolean}
*/
Tag.prototype.isSystemTag = function()
{
	return ('br i pb v'.indexOf(this.name) > -1);
}

/**
* Test whether this tag is a start tag (self-closing tags inclusive)
*
* @return {!boolean}
*/
Tag.prototype.isStartTag = function()
{
	return !!(this.type & Tag.START_TAG);
}

/**
* Test whether this tag represents verbatim text
*
* @return {!boolean}
*/
Tag.prototype.isVerbatim = function()
{
	return (this.name === 'v');
}

//==========================================================================
// Attributes handling
//==========================================================================

/**
* Return the value of given attribute
*
* @param  {!string} attrName
* @return {!string}
*/
Tag.prototype.getAttribute = function(attrName)
{
	return this.attributes[attrName];
}

/**
* Return whether given attribute is set
*
* @param  {!string} attrName
* @return {!boolean}
*/
Tag.prototype.hasAttribute = function(attrName)
{
	return (attrName in this.attributes);
}

/**
* Remove given attribute
*
* @param {!string} attrName
*/
Tag.prototype.removeAttribute = function(attrName)
{
	delete this.attributes[attrName];
}

/**
* Set the value of an attribute
*
* @param {!string} attrName  Attribute's name
* @param {*}       attrValue Attribute's value
*/
Tag.prototype.setAttribute = function(attrName, attrValue)
{
	this.attributes[attrName] = attrValue;
}

/**
* Set all of this tag's attributes at once
*
* @param {!Object} attributes
*/
Tag.prototype.setAttributes = function(attributes)
{
	this.attributes = {}

	for (var attrName in attributes)
	{
		this.attributes[attrName] = attributes[attrName];
	}
}
/**#@+
* Boolean rules bitfield
*/
/** @const */ var RULE_AUTO_CLOSE        = 1 << 0;
/** @const */ var RULE_AUTO_REOPEN       = 1 << 1;
/** @const */ var RULE_BREAK_PARAGRAPH   = 1 << 2;
/** @const */ var RULE_CREATE_PARAGRAPHS = 1 << 3;
/** @const */ var RULE_DISABLE_AUTO_BR   = 1 << 4;
/** @const */ var RULE_ENABLE_AUTO_BR    = 1 << 5;
/** @const */ var RULE_IGNORE_TAGS       = 1 << 6;
/** @const */ var RULE_IGNORE_TEXT       = 1 << 7;
/** @const */ var RULE_IGNORE_WHITESPACE = 1 << 8;
/** @const */ var RULE_IS_TRANSPARENT    = 1 << 9;
/** @const */ var RULE_PREVENT_BR        = 1 << 10;
/** @const */ var RULE_SUSPEND_AUTO_BR   = 1 << 11;
/** @const */ var RULE_TRIM_FIRST_LINE   = 1 << 12;
/**#@-*/

/**
* @const Bitwise disjunction of rules related to automatic line breaks
*/
var RULES_AUTO_LINEBREAKS = RULE_DISABLE_AUTO_BR | RULE_ENABLE_AUTO_BR | RULE_SUSPEND_AUTO_BR;

/**
* @const Bitwise disjunction of rules that are inherited by subcontexts
*/
var RULES_INHERITANCE = RULE_ENABLE_AUTO_BR;

/**
* @const All the characters that are considered whitespace
*/
var WHITESPACE = " \n\t";

/**
* @type {!Object.<string,!number>} Number of open tags for each tag name
*/
var cntOpen;

/**
* @type {!Object.<string,!number>} Number of times each tag has been used
*/
var cntTotal;

/**
* @type {!Object} Current context
*/
var context;

/**
* @type {!number} How hard the parser has worked on fixing bad markup so far
*/
var currentFixingCost;

/**
* @type {Tag} Current tag being processed
*/
var currentTag;

/**
* @type {!boolean} Whether the output contains "rich" tags, IOW any tag that is not <p> or <br/>
*/
var isRich;

/**
* @type {!Logger} This parser's logger
*/
var logger = new Logger;

/**
* @type {!number} How hard the parser should work on fixing bad markup
*/
var maxFixingCost = 10000;

/**
* @type {!Object} Associative array of namespace prefixes in use in document (prefixes used as key)
*/
var namespaces;

/**
* @type {!Array.<!Tag>} Stack of open tags (instances of Tag)
*/
var openTags;

/**
* @type {!string} This parser's output
*/
var output;

/**
* @type {!Object.<!Object>}
*/
var plugins={"Autoemail":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={attrName:"email",tagName:"EMAIL"};
					var tagName  = config.tagName,
	attrName = config.attrName;

matches.forEach(function(m)
{
	// Create a zero-width start tag right before the address
	var startTag = addStartTag(tagName, m[0][1], 0);
	startTag.setAttribute(attrName, m[0][0]);

	// Create a zero-width end tag right after the address
	var endTag = addEndTag(tagName, m[0][1] + m[0][0].length, 0);

	// Pair the tags together
	startTag.pairWith(endTag);
});
				},quickMatch:"@",regexp:/\b[-a-z0-9_+.]+@[-a-z0-9.]*[a-z0-9]/ig,regexpLimit:50000},"Autoimage":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={attrName:"src",tagName:"IMG"};
					var tagName  = config.tagName,
	attrName = config.attrName;

matches.forEach(function(m)
{
	addTagPair(tagName, m[0][1], 0, m[0][1] + m[0][0].length, 0, 2).setAttribute(attrName, m[0][0]);
});
				},quickMatch:":\/\/",regexp:/\bhttps?:\/\/[-.\w]+\/(?:[-+.:\/\w]|%[0-9a-f]{2}|\(\w+\))+\.(?:gif|jpe?g|png)(?!\S)/ig,regexpLimit:50000},"Autolink":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={attrName:"url",tagName:"URL"};
					matches.forEach(function(m)
{
	// Linkify the trimmed URL
	linkifyUrl(m[0][1], trimUrl(m[0][0]));
});

/**
* Linkify given URL at given position
*
* @param {!number} tagPos URL's position in the text
* @param {!string} url    URL
*/
function linkifyUrl(tagPos, url)
{
	// Ensure that the anchor (scheme/www) is still there
	if (!/^www\.|^[^:]+:/i.test(url))
	{
		return;
	}

	// Create a zero-width end tag right after the URL
	var endTag = addEndTag(config.tagName, tagPos + url.length, 0);

	// If the URL starts with "www." we prepend "http://"
	if (url.charAt(3) === '.')
	{
		url = 'http://' + url;
	}

	// Create a zero-width start tag right before the URL, with a slightly worse priority to
	// allow specialized plugins to use the URL instead
	var startTag = addStartTag(config.tagName, tagPos, 0, 1);
	startTag.setAttribute(config.attrName, url);

	// Pair the tags together
	startTag.pairWith(endTag);
};

/**
* Remove trailing punctuation from given URL
*
* We remove most ASCII non-letters from the end of the string.
* Exceptions:
*  - dashes (some YouTube URLs end with a dash due to the video ID)
*  - equal signs (because of "foo?bar="),
*  - trailing slashes,
*  - closing parentheses are balanced separately.
*
* @param  {!string} url Original URL
* @return {!string}     Trimmed URL
*/
function trimUrl(url)
{
	return url.replace(/(?![-=\/)])[\s!-.:-@[-`{-~]+$/, '');
}
				},quickMatch:":\/\/",regexp:/\bhttps?:\/\/\S(?:[^\s()\[\]\uFF01-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65]|\([^\s()]*\)|\[\w*\])+/ig,regexpLimit:50000},"BBCodes":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={bbcodes:{"ABCNEWS":{contentAttributes:["url"],defaultAttribute:"url"},"AMAZON":{contentAttributes:["url"],defaultAttribute:"url"},"AUDIOBOOM":{contentAttributes:["url"],defaultAttribute:"url"},"AUDIOMACK":{contentAttributes:["url"],defaultAttribute:"url"},"BANDCAMP":{contentAttributes:["url"],defaultAttribute:"url"},"BBCNEWS":{contentAttributes:["url"],defaultAttribute:"url"},"BLAB":{contentAttributes:["url"],defaultAttribute:"url"},"BLEACHERREPORT":{contentAttributes:["url"],defaultAttribute:"url"},"BREAK":{contentAttributes:["url"],defaultAttribute:"url"},"BRIGHTCOVE":{contentAttributes:["url"],defaultAttribute:"url"},"CBSNEWS":{contentAttributes:["url"],defaultAttribute:"url"},"CNBC":{contentAttributes:["url"],defaultAttribute:"url"},"CNN":{contentAttributes:["url"],defaultAttribute:"url"},"CNNMONEY":{contentAttributes:["url"],defaultAttribute:"url"},"COLLEGEHUMOR":{contentAttributes:["url"],defaultAttribute:"url"},"COMEDYCENTRAL":{contentAttributes:["url"],defaultAttribute:"url"},"COUB":{contentAttributes:["url"],defaultAttribute:"url"},"DAILYMOTION":{contentAttributes:["url"],defaultAttribute:"url"},"DEMOCRACYNOW":{contentAttributes:["url"],defaultAttribute:"url"},"DUMPERT":{contentAttributes:["url"],defaultAttribute:"url"},"EIGHTTRACKS":{contentAttributes:["url"],defaultAttribute:"url"},"ESPN":{contentAttributes:["url"],defaultAttribute:"url"},"FACEBOOK":{contentAttributes:["url"],defaultAttribute:"url"},"FLICKR":{contentAttributes:["url"],defaultAttribute:"url"},"FORATV":{contentAttributes:["url"],defaultAttribute:"url"},"FOXNEWS":{contentAttributes:["url"],defaultAttribute:"url"},"FUNNYORDIE":{contentAttributes:["url"],defaultAttribute:"url"},"GAMESPOT":{contentAttributes:["url"],defaultAttribute:"url"},"GAMETRAILERS":{contentAttributes:["url"],defaultAttribute:"url"},"GETTY":{contentAttributes:["url"],defaultAttribute:"url"},"GFYCAT":{contentAttributes:["url"],defaultAttribute:"url"},"GIFS":{contentAttributes:["url"],defaultAttribute:"url"},"GIST":{contentAttributes:["url"],defaultAttribute:"url"},"GLOBALNEWS":{contentAttributes:["url"],defaultAttribute:"url"},"GOFUNDME":{contentAttributes:["url"],defaultAttribute:"url"},"GOOGLEDRIVE":{contentAttributes:["url"],defaultAttribute:"url"},"GOOGLEPLUS":{contentAttributes:["url"],defaultAttribute:"url"},"GOOGLESHEETS":{contentAttributes:["url"],defaultAttribute:"url"},"HEALTHGURU":{contentAttributes:["url"],defaultAttribute:"url"},"HUDL":{contentAttributes:["url"],defaultAttribute:"url"},"HULU":{contentAttributes:["url"],defaultAttribute:"url"},"HUMORTVNL":{contentAttributes:["url"],defaultAttribute:"url"},"IGN":{contentAttributes:["url"],defaultAttribute:"url"},"IMDB":{contentAttributes:["url"],defaultAttribute:"url"},"IMGUR":{contentAttributes:["url"],defaultAttribute:"url"},"INDIEGOGO":{contentAttributes:["url"],defaultAttribute:"url"},"INSTAGRAM":{contentAttributes:["url"],defaultAttribute:"url"},"INTERNETARCHIVE":{contentAttributes:["url"],defaultAttribute:"url"},"IZLESENE":{contentAttributes:["url"],defaultAttribute:"url"},"JWPLATFORM":{contentAttributes:["url"],defaultAttribute:"url"},"KHL":{contentAttributes:["url"],defaultAttribute:"url"},"KICKSTARTER":{contentAttributes:["url"],defaultAttribute:"url"},"KISSVIDEO":{contentAttributes:["url"],defaultAttribute:"url"},"LIBSYN":{contentAttributes:["url"],defaultAttribute:"url"},"LIVECAP":{contentAttributes:["url"],defaultAttribute:"url"},"LIVELEAK":{contentAttributes:["url"],defaultAttribute:"url"},"LIVESTREAM":{contentAttributes:["url"],defaultAttribute:"url"},"MAILRU":{contentAttributes:["url"],defaultAttribute:"url"},"MEDIA":{contentAttributes:["url"],defaultAttribute:"site"},"MEDIUM":{contentAttributes:["url"],defaultAttribute:"url"},"METACAFE":{contentAttributes:["url"],defaultAttribute:"url"},"MIXCLOUD":{contentAttributes:["url"],defaultAttribute:"url"},"MLB":{contentAttributes:["url"],defaultAttribute:"url"},"MRCTV":{contentAttributes:["url"],defaultAttribute:"url"},"MSNBC":{contentAttributes:["url"],defaultAttribute:"url"},"NATGEOCHANNEL":{contentAttributes:["url"],defaultAttribute:"url"},"NATGEOVIDEO":{contentAttributes:["url"],defaultAttribute:"url"},"NBCNEWS":{contentAttributes:["url"],defaultAttribute:"url"},"NBCSPORTS":{contentAttributes:["url"],defaultAttribute:"url"},"NHL":{contentAttributes:["url"],defaultAttribute:"url"},"NPR":{contentAttributes:["url"],defaultAttribute:"url"},"NYTIMES":{contentAttributes:["url"],defaultAttribute:"url"},"ODDSHOT":{contentAttributes:["url"],defaultAttribute:"url"},"PASTEBIN":{contentAttributes:["url"],defaultAttribute:"url"},"PINTEREST":{contentAttributes:["url"],defaultAttribute:"url"},"PLAYSTV":{contentAttributes:["url"],defaultAttribute:"url"},"PODBEAN":{contentAttributes:["url"],defaultAttribute:"url"},"PREZI":{contentAttributes:["url"],defaultAttribute:"url"},"REDDIT":{contentAttributes:["url"],defaultAttribute:"url"},"RUTUBE":{contentAttributes:["url"],defaultAttribute:"url"},"SCRIBD":{contentAttributes:["url"],defaultAttribute:"url"},"SLIDESHARE":{contentAttributes:["url"],defaultAttribute:"url"},"SOUNDCLOUD":{contentAttributes:["url"],defaultAttribute:"url"},"SPORTSNET":{contentAttributes:["url"],defaultAttribute:"url"},"SPOTIFY":{contentAttributes:["url"],defaultAttribute:"url"},"STEAMSTORE":{contentAttributes:["url"],defaultAttribute:"url"},"STITCHER":{contentAttributes:["url"],defaultAttribute:"url"},"STRAWPOLL":{contentAttributes:["url"],defaultAttribute:"url"},"STREAMABLE":{contentAttributes:["url"],defaultAttribute:"url"},"TEAMCOCO":{contentAttributes:["url"],defaultAttribute:"url"},"TED":{contentAttributes:["url"],defaultAttribute:"url"},"THEATLANTIC":{contentAttributes:["url"],defaultAttribute:"url"},"THEGUARDIAN":{contentAttributes:["url"],defaultAttribute:"url"},"THEONION":{contentAttributes:["url"],defaultAttribute:"url"},"TINYPIC":{contentAttributes:["url"],defaultAttribute:"url"},"TMZ":{contentAttributes:["url"],defaultAttribute:"url"},"TRAILERADDICT":{contentAttributes:["url"],defaultAttribute:"url"},"TUMBLR":{contentAttributes:["url"],defaultAttribute:"url"},"TWITCH":{contentAttributes:["url"],defaultAttribute:"url"},"TWITTER":{contentAttributes:["url"],defaultAttribute:"url"},"USTREAM":{contentAttributes:["url"],defaultAttribute:"url"},"VBOX7":{contentAttributes:["url"],defaultAttribute:"url"},"VEOH":{contentAttributes:["url"],defaultAttribute:"url"},"VEVO":{contentAttributes:["url"],defaultAttribute:"url"},"VIAGAME":{contentAttributes:["url"],defaultAttribute:"url"},"VIDEODETECTIVE":{contentAttributes:["url"],defaultAttribute:"url"},"VIDEOMEGA":{contentAttributes:["url"],defaultAttribute:"url"},"VIDME":{contentAttributes:["url"],defaultAttribute:"url"},"VIMEO":{contentAttributes:["url"],defaultAttribute:"url"},"VINE":{contentAttributes:["url"],defaultAttribute:"url"},"VK":{contentAttributes:["url"],defaultAttribute:"url"},"VOCAROO":{contentAttributes:["url"],defaultAttribute:"url"},"VOX":{contentAttributes:["url"],defaultAttribute:"url"},"WASHINGTONPOST":{contentAttributes:["url"],defaultAttribute:"url"},"WSHH":{contentAttributes:["url"],defaultAttribute:"url"},"WSJ":{contentAttributes:["url"],defaultAttribute:"url"},"XBOXCLIPS":{contentAttributes:["url"],defaultAttribute:"url"},"XBOXDVR":{contentAttributes:["url"],defaultAttribute:"url"},"YAHOOSCREEN":{contentAttributes:["url"],defaultAttribute:"url"},"YOUKU":{contentAttributes:["url"],defaultAttribute:"url"},"YOUTUBE":{contentAttributes:["url"],defaultAttribute:"url"},"ZIPPYSHARE":{contentAttributes:["url"],defaultAttribute:"url"}}};
					/**
* @type {!Object} Attributes of the BBCode being parsed
*/
var attributes;

/**
* @type {!Object} Configuration for the BBCode being parsed
*/
var bbcodeConfig;

/**
* @type {!string} Name of the BBCode being parsed
*/
var bbcodeName;

/**
* @type {!string} Suffix of the BBCode being parsed, including its colon
*/
var bbcodeSuffix;

/**
* @type {!number} Position of the cursor in the original text
*/
var pos;

/**
* @type {!number} Position of the start of the BBCode being parsed
*/
var startPos;

/**
* @type {!number} Length of the text being parsed
*/
var textLen = text.length;

/**
* @type {!string} Text being parsed, normalized to uppercase
*/
var uppercaseText = '';

matches.forEach(function(m)
{
	bbcodeName = m[1][0].toUpperCase();
	if (!(bbcodeName in config.bbcodes))
	{
		return;
	}
	bbcodeConfig = config.bbcodes[bbcodeName];
	startPos     = m[0][1];
	pos          = startPos + m[0][0].length;

	try
	{
		parseBBCode();
	}
	catch (e)
	{
		// Do nothing
	}
});

/**
* Add the end tag that matches current BBCode
*
* @return {!Tag}
*/
function addBBCodeEndTag()
{
	return addEndTag(getTagName(), startPos, pos - startPos);
}

/**
* Add the self-closing tag that matches current BBCode
*
* @return {!Tag}
*/
function addBBCodeSelfClosingTag()
{
	var tag = addSelfClosingTag(getTagName(), startPos, pos - startPos);
	tag.setAttributes(attributes);

	return tag;
}

/**
* Add the start tag that matches current BBCode
*
* @return {!Tag}
*/
function addBBCodeStartTag()
{
	var tag = addStartTag(getTagName(), startPos, pos - startPos);
	tag.setAttributes(attributes);

	return tag;
}

/**
* Parse the end tag that matches given BBCode name and suffix starting at current position
*
* @return {Tag}
*/
function captureEndTag()
{
	if (!uppercaseText)
	{
		uppercaseText = text.toUpperCase();
	}
	var match     = '[/' + bbcodeName + bbcodeSuffix + ']',
		endTagPos = uppercaseText.indexOf(match, pos);
	if (endTagPos < 0)
	{
		return null;
	}

	return addEndTag(getTagName(), endTagPos, match.length);
}

/**
* Get the tag name for current BBCode
*
* @return string
*/
function getTagName()
{
	// Use the configured tagName if available, or reuse the BBCode's name otherwise
	return bbcodeConfig.tagName || bbcodeName;
}

/**
* Parse attributes starting at current position
*
* @return array Associative array of [name => value]
*/
function parseAttributes()
{
	var firstPos = pos, attrName;
	attributes = {};
	while (pos < textLen)
	{
		var c = text.charAt(pos);
		if (" \n\t".indexOf(c) > -1)
		{
			++pos;
			continue;
		}
		if ('/]'.indexOf(c) > -1)
		{
			return;
		}

		// Capture the attribute name
		var spn = /^[-\w]*/.exec(text.substr(pos, 100))[0].length;
		if (spn)
		{
			attrName = text.substr(pos, spn).toLowerCase();
			pos += spn;
			if (pos >= textLen)
			{
				// The attribute name extends to the end of the text
				throw '';
			}
			if (text.charAt(pos) !== '=')
			{
				// It's an attribute name not followed by an equal sign, ignore it
				continue;
			}
		}
		else if (c === '=' && pos === firstPos)
		{
			// This is the default param, e.g. [quote=foo]
			attrName = bbcodeConfig.defaultAttribute || bbcodeName.toLowerCase();
		}
		else
		{
			throw '';
		}

		// Move past the = and make sure we're not at the end of the text
		if (++pos >= textLen)
		{
			throw '';
		}

		attributes[attrName] = parseAttributeValue();
	}
}

/**
* Parse the attribute value starting at current position
*
* @return string
*/
function parseAttributeValue()
{
	// Test whether the value is in quotes
	if (text.charAt(pos) === '"' || text.charAt(pos) === "'")
	{
		return parseQuotedAttributeValue();
	}

	// Capture everything up to whichever comes first:
	//  - an endline
	//  - whitespace followed by a slash and a closing bracket
	//  - a closing bracket, optionally preceded by whitespace
	//  - whitespace followed by another attribute (name followed by equal sign)
	//
	// NOTE: this is for compatibility with some forums (such as vBulletin it seems)
	//       that do not put attribute values in quotes, e.g.
	//       [quote=John Smith;123456] (quoting "John Smith" from post #123456)
	var match = /[^\]\n]*?(?=\s*(?:\s\/)?\]|\s+[-\w]+=)/.exec(text.substr(pos));
	if (!match)
	{
		throw '';
	}

	var attrValue = match[0];
	pos += attrValue.length;

	return attrValue;
}

/**
* Parse current BBCode
*
* @return void
*/
function parseBBCode()
{
	parseBBCodeSuffix();

	// Test whether this is an end tag
	if (text.charAt(startPos + 1) === '/')
	{
		// Test whether the tag is properly closed and whether this tag has an identifier.
		// We skip end tags that carry an identifier because they're automatically added
		// when their start tag is processed
		if (text.charAt(pos) === ']' && bbcodeSuffix === '')
		{
			++pos;
			addBBCodeEndTag();
		}

		return;
	}

	// Parse attributes and fill in the blanks with predefined attributes
	parseAttributes();
	if (bbcodeConfig.predefinedAttributes)
	{
		for (var attrName in bbcodeConfig.predefinedAttributes)
		{
			if (!(attrName in attributes))
			{
				attributes[attrName] = bbcodeConfig.predefinedAttributes[attrName];
			}
		}
	}

	// Test whether the tag is properly closed
	if (text.charAt(pos) === ']')
	{
		++pos;
	}
	else
	{
		// Test whether this is a self-closing tag
		if (text.substr(pos, 2) === '/]')
		{
			pos += 2;
			addBBCodeSelfClosingTag();
		}

		return;
	}

	// Record the names of attributes that need the content of this tag
	var contentAttributes = [];
	if (bbcodeConfig.contentAttributes)
	{
		bbcodeConfig.contentAttributes.forEach(function(attrName)
		{
			if (!(attrName in attributes))
			{
				contentAttributes.push(attrName);
			}
		});
	}

	// Look ahead and parse the end tag that matches this tag, if applicable
	var requireEndTag = (bbcodeSuffix || bbcodeConfig.forceLookahead),
		endTag = (requireEndTag || contentAttributes.length) ? captureEndTag() : null;
	if (endTag)
	{
		contentAttributes.forEach(function(attrName)
		{
			attributes[attrName] = text.substr(pos, endTag.getPos() - pos);
		});
	}
	else if (requireEndTag)
	{
		return;
	}

	// Create this start tag
	var tag = addBBCodeStartTag();

	// If an end tag was created, pair it with this start tag
	if (endTag)
	{
		tag.pairWith(endTag);
	}
}

/**
* Parse the BBCode suffix starting at current position
*
* Used to explicitly pair specific tags together, e.g.
*   [code:123][code]type your code here[/code][/code:123]
*
* @return void
*/
function parseBBCodeSuffix()
{
	bbcodeSuffix = '';
	if (text[pos] === ':')
	{
		// Capture the colon and the (0 or more) digits following it
		bbcodeSuffix = /^:\d*/.exec(text.substr(pos))[0];

		// Move past the suffix
		pos += bbcodeSuffix.length;
	}
}

/**
* Parse a quoted attribute value that starts at current offset
*
* @return {!string}
*/
function parseQuotedAttributeValue()
{
	var quote    = text.charAt(pos),
		valuePos = pos + 1;
	while (1)
	{
		// Look for the next quote
		pos = text.indexOf(quote, pos + 1);
		if (pos < 0)
		{
			// No matching quote. Apparently that string never ends...
			throw '';
		}

		// Test for an odd number of backslashes before this character
		var n = 0;
		do
		{
			++n;
		}
		while (text.charAt(pos - n) === '\\');

		if (n % 2)
		{
			// If n is odd, it means there's an even number of backslashes. We can exit this loop
			break;
		}
	}

	// Unescape special characters ' " and \
	var attrValue = text.substr(valuePos, pos - valuePos).replace(/\\([\\'"])/g, '$1');

	// Skip past the closing quote
	++pos;

	return attrValue;
}
				},quickMatch:"[",regexp:/\[\/?(\*|[-\w]+)(?=[\]\s=:\/])/g,regexpLimit:50000},"Emoticons":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={tagName:"E"};
					matches.forEach(function(m)
{
	if (HINT.EMOTICONS_NOT_AFTER && config.notAfter && m[0][1] && config.notAfter.test(text.charAt(m[0][1] - 1)))
	{
		return;
	}

	addSelfClosingTag(config.tagName, m[0][1], m[0][0].length);
});
				},quickMatch:":)",regexp:/:\)/g,regexpLimit:50000},"Escaper":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={tagName:"ESC"};
					matches.forEach(function(m)
{
	addTagPair(
		config.tagName,
		m[0][1],
		1,
		m[0][1] + m[0][0].length,
		0
	);
});
				},quickMatch:"\\",regexp:/\\[-!#()*+.:<>@[\\\]^_`{|}]/g,regexpLimit:50000},"Litedown":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={decodeHtmlEntities:!1};
					var hasEscapedChars, hasRefs, refs, startTagLen, startTagPos, endTagPos, endTagLen;

// Unlike the PHP parser, init() must not take an argument
init();

// Match block-level markup as well as forced line breaks
matchBlockLevelMarkup();

// Capture link references after block markup as been overwritten
matchLinkReferences();

// Inline code must be done first to avoid false positives in other inline markup
matchInlineCode();

// Do the rest of inline markup. Images must be matched before links
matchImages();
matchLinks();
matchStrikethrough();
matchSuperscript();
matchEmphasis();
matchForcedLineBreaks();

/**
* Add an image tag for given text span
*
* @param {!number} startTagPos Start tag position
* @param {!number} endTagPos   End tag position
* @param {!number} endTagLen   End tag length
* @param {!string} linkInfo    URL optionally followed by space and a title
* @param {!string} alt         Value for the alt attribute
*/
function addImageTag(startTagPos, endTagPos, endTagLen, linkInfo, alt)
{
	var tag = addTagPair('IMG', startTagPos, 2, endTagPos, endTagLen);
	setLinkAttributes(tag, linkInfo, 'src');
	tag.setAttribute('alt', decode(alt));

	// Overwrite the markup
	overwrite(startTagPos, endTagPos + endTagLen - startTagPos);
}

/**
* Add the tag pair for an inline code span
*
* @param {!Object} left  Left marker
* @param {!Object} right Right marker
*/
function addInlineCodeTags(left, right)
{
	var startTagPos = left.pos,
		startTagLen = left.len + left.trimAfter,
		endTagPos   = right.pos - right.trimBefore,
		endTagLen   = right.len + right.trimBefore;
	addTagPair('C', startTagPos, startTagLen, endTagPos, endTagLen);
	overwrite(startTagPos, endTagPos + endTagLen - startTagPos);
}

/**
* Add an image tag for given text span
*
* @param {!number} startTagPos Start tag position
* @param {!number} endTagPos   End tag position
* @param {!number} endTagLen   End tag length
* @param {!string} linkInfo    URL optionally followed by space and a title
*/
function addLinkTag(startTagPos, endTagPos, endTagLen, linkInfo)
{
	// Give the link a slightly worse priority if this is a implicit reference and a slightly
	// better priority if it's an explicit reference or an inline link or to give it precedence
	// over possible BBCodes such as [b](https://en.wikipedia.org/wiki/B)
	var priority = (endTagLen === 1) ? 1 : -1;

	var tag = addTagPair('URL', startTagPos, 1, endTagPos, endTagLen, priority);
	setLinkAttributes(tag, linkInfo, 'url');

	// Overwrite the markup without touching the link's text
	overwrite(startTagPos, 1);
	overwrite(endTagPos,   endTagLen);
}

/**
* Close a list at given offset
*
* @param  {!Array}  list
* @param  {!number} textBoundary
*/
function closeList(list, textBoundary)
{
	addEndTag('LIST', textBoundary, 0).pairWith(list.listTag);
	addEndTag('LI',   textBoundary, 0).pairWith(list.itemTag);

	if (list.tight)
	{
		list.itemTags.forEach(function(itemTag)
		{
			itemTag.removeFlags(RULE_CREATE_PARAGRAPHS);
		});
	}
}

/**
* Compute the amount of text to ignore at the start of a quote line
*
* @param  {!string} str           Original quote markup
* @param  {!number} maxQuoteDepth Maximum quote depth
* @return {!number}               Number of characters to ignore
*/
function computeQuoteIgnoreLen(str, maxQuoteDepth)
{
	var remaining = str;
	while (--maxQuoteDepth >= 0)
	{
		remaining = remaining.replace(/^ *> ?/, '');
	}

	return str.length - remaining.length;
}

/**
* Decode a chunk of encoded text to be used as an attribute value
*
* Decodes escaped literals and removes slashes and 0x1A characters
*
* @param  {!string}  str Encoded text
* @return {!string}      Decoded text
*/
function decode(str)
{
	if (HINT.LITEDOWN_DECODE_HTML_ENTITIES && config.decodeHtmlEntities && str.indexOf('&') > -1)
	{
		str = html_entity_decode(str);
	}
	str = str.replace(/\x1A/g, '');

	if (hasEscapedChars)
	{
		str = str.replace(
			/\x1B./g,
			function (seq)
			{
				return {
					"\x1B0": '!', "\x1B1": '"', "\x1B2": "'", "\x1B3": '(',
					"\x1B4": ')', "\x1B5": '*', "\x1B6": '[', "\x1B7": '\\',
					"\x1B8": ']', "\x1B9": '^', "\x1BA": '_', "\x1BB": '`',
					"\x1BC": '~'
				}[seq];
			}
		);
	}

	return str;
}

/**
* Encode escaped literals that have a special meaning
*
* @param  {!string}  str Original text
* @return {!string}      Encoded text
*/
function encode(str)
{
	return str.replace(
		/\\[!"'()*[\\\]^_`~]/g,
		function (str)
		{
			return {
				'\\!': "\x1B0", '\\"': "\x1B1", "\\'": "\x1B2", '\\(' : "\x1B3",
				'\\)': "\x1B4", '\\*': "\x1B5", '\\[': "\x1B6", '\\\\': "\x1B7",
				'\\]': "\x1B8", '\\^': "\x1B9", '\\_': "\x1BA", '\\`' : "\x1BB",
				'\\~': "\x1BC"
			}[str];
		}
	);
}

/**
* Return the length of the markup at the end of an ATX header
*
* @param  {!number} startPos Start of the header's text
* @param  {!number} endPos   End of the header's text
* @return {!number}
*/
function getAtxHeaderEndTagLen(startPos, endPos)
{
	var content = text.substr(startPos, endPos - startPos),
		m = /[ \t]*#*[ \t]*$/.exec(content);

	return m[0].length;
}

/**
* Get emphasis markup split by block
*
* @param  {!RegExp} regexp Regexp used to match emphasis
* @param  {!number} pos    Position in the text of the first emphasis character
* @return {!Array}         Each array contains a list of [matchPos, matchLen] pairs
*/
function getEmphasisByBlock(regexp, pos)
{
	var block    = [],
		blocks   = [],
		breakPos = breakPos  = text.indexOf("\x17", pos),
		m;

	regexp.lastIndex = pos;
	while (m = regexp.exec(text))
	{
		var matchPos = m['index'],
			matchLen = m[0].length;

		// Test whether we've just passed the limits of a block
		if (matchPos > breakPos)
		{
			blocks.push(block);
			block    = [];
			breakPos = text.indexOf("\x17", matchPos);
		}

		// Test whether we should ignore this markup
		if (!ignoreEmphasis(matchPos, matchLen))
		{
			block.push([matchPos, matchLen]);
		}
	}
	blocks.push(block);

	return blocks;
}

/**
* Capture and return inline code markers
*
* @return {!Array<!Object>}
*/
function getInlineCodeMarkers()
{
	var pos = text.indexOf('`');
	if (pos < 0)
	{
		return [];
	}

	var regexp   = /(`+)(\s*)[^\x17`]*/g,
		trimNext = 0,
		markers  = [],
		_text    = text.replace(/\x1BB/g, '\\`'),
		m;
	regexp.lastIndex = pos;
	while (m = regexp.exec(_text))
	{
		markers.push({
			pos        : m['index'],
			len        : m[1].length,
			trimBefore : trimNext,
			trimAfter  : m[2].length,
			next       : m['index'] + m[0].length
		});
		trimNext = m[0].length - m[0].replace(/\s+$/, '').length;
	}

	return markers;
}

/**
* Capture and return labels used in current text
*
* @return {!Object} Labels' text position as keys, lowercased text content as values
*/
function getLabels()
{
	var labels = {}, m, regexp = /\[((?:[^\x17[\]]|\[[^\x17[\]]*\])*)\]/g;
	while (m = regexp.exec(text))
	{
		labels[m['index']] = m[1].toLowerCase();
	}

	return labels;
}

/**
* Capture lines that contain a Setext-tyle header
*
* @return {!Object}
*/
function getSetextLines()
{
	var setextLines = {};

	// Capture the underlines used for Setext-style headers
	if (text.indexOf('-') === -1 && text.indexOf('=') === -1)
	{
		return setextLines;
	}

	// Capture the any series of - or = alone on a line, optionally preceded with the
	// angle brackets notation used in blockquotes
	var m, regexp = /^(?=[-=>])(?:> ?)*(?=[-=])(?:-+|=+) *$/gm;

	while (m = regexp.exec(text))
	{
		var match    = m[0],
			matchPos = m['index'];

		// Compute the position of the end tag. We start on the LF character before the
		// match and keep rewinding until we find a non-space character
		var endTagPos = matchPos - 1;
		while (endTagPos > 0 && text[endTagPos - 1] === ' ')
		{
			--endTagPos;
		}

		// Store at the offset of the LF character
		setextLines[matchPos - 1] = {
			endTagLen  : matchPos + match.length - endTagPos,
			endTagPos  : endTagPos,
			quoteDepth : match.length - match.replace(/>/g, '').length,
			tagName    : (match.charAt(0) === '=') ? 'H1' : 'H2'
		};
	}

	return setextLines;
}

/**
* Test whether emphasis should be ignored at the given position in the text
*
* @param  {!number}  matchPos Position of the emphasis in the text
* @param  {!number}  matchLen Length of the emphasis
* @return {!boolean}
*/
function ignoreEmphasis(matchPos, matchLen)
{
	// Ignore single underscores between alphanumeric characters
	return (text[matchPos] === '_' && matchLen === 1 && isSurroundedByAlnum(matchPos, matchLen));
}

/**
* Initialize this parser
*/
function init()
{
	if (text.indexOf('\\') < 0)
	{
		hasEscapedChars = false;
	}
	else
	{
		hasEscapedChars = true;

		// Encode escaped literals that have a special meaning otherwise, so that we don't have
		// to take them into account in regexps
		text = encode(text);
	}

	// We append a couple of lines and a non-whitespace character at the end of the text in
	// order to trigger the closure of all open blocks such as quotes and lists
	text += "\n\n\x17";
}

/**
* Test whether given character is alphanumeric
*
* @param  {!string}  chr
* @return {!boolean}
*/
function isAlnum(chr)
{
	return (' abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.indexOf(chr) > 0);
}

/**
* Test whether a length of text is surrounded by alphanumeric characters
*
* @param  {!number}  matchPos Start of the text
* @param  {!number}  matchLen Length of the text
* @return {!boolean}
*/
function isSurroundedByAlnum(matchPos, matchLen)
{
	return (matchPos > 0 && isAlnum(text[matchPos - 1]) && isAlnum(text[matchPos + matchLen]));
}

/**
* Mark the boundary of a block in the original text
*
* @param {!number} pos
*/
function markBoundary(pos)
{
	text = text.substr(0, pos) + "\x17" + text.substr(pos + 1);
}

/**
* Match block-level markup, as well as forced line breaks and headers
*/
function matchBlockLevelMarkup()
{
	var codeFence,
		codeIndent   = 4,
		codeTag,
		lineIsEmpty  = true,
		lists        = [],
		listsCnt     = 0,
		newContext   = false,
		quotes       = [],
		quotesCnt    = 0,
		setextLines  = getSetextLines(),
		textBoundary = 0,
		breakParagraph,
		continuation,
		endTag,
		ignoreLen,
		indentStr,
		indentLen,
		lfPos,
		listIndex,
		maxIndent,
		minIndent,
		quoteDepth,
		tagPos,
		tagLen;

	// Capture all the lines at once so that we can overwrite newlines safely, without preventing
	// further matches
	var matches = [],
		m,
		regexp = /^(?:(?=[-*+\d \t>`~#_])((?: {0,3}> ?)+)?([ \t]+)?(\* *\* *\*[* ]*$|- *- *-[- ]*$|_ *_ *_[_ ]*$)?((?:[-*+]|\d+\.)[ \t]+(?=\S))?[ \t]*(#{1,6}[ \t]+|```+[^`\n]*$|~~~+[^~\n]*$)?)?/gm;
	while (m = regexp.exec(text))
	{
		matches.push(m);

		// Move regexp.lastIndex if the current match is empty
		if (m['index'] === regexp['lastIndex'])
		{
			++regexp['lastIndex'];
		}
	}

	matches.forEach(function(m)
	{
		var matchPos = m['index'],
			matchLen = m[0].length;

		ignoreLen  = 0;
		quoteDepth = 0;

		// If the last line was empty then this is not a continuation, and vice-versa
		continuation = !lineIsEmpty;

		// Capture the position of the end of the line and determine whether the line is empty
		lfPos       = text.indexOf("\n", matchPos);
		lineIsEmpty = (lfPos === matchPos + matchLen && !m[3] && !m[4] && !m[5]);

		// If the match is empty we need to move the cursor manually
		if (!matchLen)
		{
			++regexp.lastIndex;
		}

		// If the line is empty and it's the first empty line then we break current paragraph.
		breakParagraph = (lineIsEmpty && continuation);

		// Count quote marks
		if (m[1])
		{
			quoteDepth = m[1].length - m[1].replace(/>/g, '').length;
			ignoreLen  = m[1].length;
			if (codeTag && codeTag.hasAttribute('quoteDepth'))
			{
				quoteDepth = Math.min(quoteDepth, codeTag.getAttribute('quoteDepth'));
				ignoreLen  = computeQuoteIgnoreLen(m[1], quoteDepth);
			}

			// Overwrite quote markup
			overwrite(matchPos, ignoreLen);
		}

		// Close supernumerary quotes
		if (quoteDepth < quotesCnt && !continuation)
		{
			newContext = true;

			do
			{
				addEndTag('QUOTE', textBoundary, 0).pairWith(quotes.pop());
			}
			while (quoteDepth < --quotesCnt);
		}

		// Open new quotes
		if (quoteDepth > quotesCnt && !lineIsEmpty)
		{
			newContext = true;

			do
			{
				var tag = addStartTag('QUOTE', matchPos, 0, quotesCnt - 999);
				quotes.push(tag);
			}
			while (quoteDepth > ++quotesCnt);
		}

		// Compute the width of the indentation
		var indentWidth = 0,
			indentPos   = 0;
		if (m[2] && !codeFence)
		{
			indentStr = m[2];
			indentLen = indentStr.length;

			do
			{
				if (indentStr.charAt(indentPos) === ' ')
				{
					++indentWidth;
				}
				else
				{
					indentWidth = (indentWidth + 4) & ~3;
				}
			}
			while (++indentPos < indentLen && indentWidth < codeIndent);
		}

		// Test whether we're out of a code block
		if (codeTag && !codeFence && indentWidth < codeIndent && !lineIsEmpty)
		{
			newContext = true;
		}

		if (newContext)
		{
			newContext = false;

			// Close the code block if applicable
			if (codeTag)
			{
				// Overwrite the whole block
				overwrite(codeTag.getPos(), textBoundary - codeTag.getPos());

				endTag = addEndTag('CODE', textBoundary, 0, -1);
				endTag.pairWith(codeTag);
				codeTag = null;
				codeFence = null;
			}

			// Close all the lists
			lists.forEach(function(list)
			{
				closeList(list, textBoundary);
			});
			lists    = [];
			listsCnt = 0;

			// Mark the block boundary
			if (matchPos)
			{
				markBoundary(matchPos - 1);
			}
		}

		if (indentWidth >= codeIndent)
		{
			if (codeTag || !continuation)
			{
				// Adjust the amount of text being ignored
				ignoreLen = (m[1] || '').length + indentPos;

				if (!codeTag)
				{
					// Create code block
					codeTag = addStartTag('CODE', matchPos + ignoreLen, 0, -999);
				}

				// Clear the captures to prevent any further processing
				m = {};
			}
		}
		else
		{
			var hasListItem = !!m[4];

			if (!indentWidth && !continuation && !hasListItem)
			{
				// Start of a new context
				listIndex = -1;
			}
			else if (continuation && !hasListItem)
			{
				// Continuation of current list item or paragraph
				listIndex = listsCnt - 1;
			}
			else if (!listsCnt)
			{
				// We're not inside of a list already, we can start one if there's a list item
				// and it's either not in continuation of a paragraph or immediately after a
				// block
				if (hasListItem && (!continuation || text.charAt(matchPos - 1) === "\x17"))
				{
					// Start of a new list
					listIndex = 0;
				}
				else
				{
					// We're in a normal paragraph
					listIndex = -1;
				}
			}
			else
			{
				// We're inside of a list but we need to compute the depth
				listIndex = 0;
				while (listIndex < listsCnt && indentWidth > lists[listIndex].maxIndent)
				{
					++listIndex;
				}
			}

			// Close deeper lists
			while (listIndex < listsCnt - 1)
			{
				closeList(lists.pop(), textBoundary);
				--listsCnt;
			}

			// If there's no list item at current index, we'll need to either create one or
			// drop down to previous index, in which case we have to adjust maxIndent
			if (listIndex === listsCnt && !hasListItem)
			{
				--listIndex;
			}

			if (hasListItem && listIndex >= 0)
			{
				breakParagraph = true;

				// Compute the position and amount of text consumed by the item tag
				tagPos = matchPos + ignoreLen + indentPos
				tagLen = m[4].length;

				// Create a LI tag that consumes its markup
				var itemTag = addStartTag('LI', tagPos, tagLen);

				// Overwrite the markup
				overwrite(tagPos, tagLen);

				// If the list index is within current lists count it means this is not a new
				// list and we have to close the last item. Otherwise, it's a new list that we
				// have to create
				if (listIndex < listsCnt)
				{
					addEndTag('LI', textBoundary, 0).pairWith(lists[listIndex].itemTag);

					// Record the item in the list
					lists[listIndex].itemTag = itemTag;
					lists[listIndex].itemTags.push(itemTag);
				}
				else
				{
					++listsCnt;

					if (listIndex)
					{
						minIndent = lists[listIndex - 1].maxIndent + 1;
						maxIndent = Math.max(minIndent, listIndex * 4);
					}
					else
					{
						minIndent = 0;
						maxIndent = indentWidth;
					}

					// Create a 0-width LIST tag right before the item tag LI
					var listTag = addStartTag('LIST', tagPos, 0);

					// Test whether the list item ends with a dot, as in "1."
					if (m[4].indexOf('.') > -1)
					{
						listTag.setAttribute('type', 'decimal');

						var start = +m[4];
						if (start !== 1)
						{
							listTag.setAttribute('start', start);
						}
					}

					// Record the new list depth
					lists.push({
						listTag   : listTag,
						itemTag   : itemTag,
						itemTags  : [itemTag],
						minIndent : minIndent,
						maxIndent : maxIndent,
						tight     : true
					});
				}
			}

			// If we're in a list, on a non-empty line preceded with a blank line...
			if (listsCnt && !continuation && !lineIsEmpty)
			{
				// ...and this is not the first item of the list...
				if (lists[0].itemTags.length > 1 || !hasListItem)
				{
					// ...every list that is currently open becomes loose
					lists.forEach(function(list)
					{
						list.tight = false;
					});
				}
			}

			codeIndent = (listsCnt + 1) * 4;
		}

		if (m[5])
		{
			// Headers
			if (m[5].charAt(0) === '#')
			{
				startTagLen = m[5].length;
				startTagPos = matchPos + matchLen - startTagLen;
				endTagLen   = getAtxHeaderEndTagLen(matchPos + matchLen, lfPos);
				endTagPos   = lfPos - endTagLen;

				addTagPair('H' + /#{1,6}/.exec(m[5])[0].length, startTagPos, startTagLen, endTagPos, endTagLen);

				// Mark the start and the end of the header as boundaries
				markBoundary(startTagPos);
				markBoundary(lfPos);

				if (continuation)
				{
					breakParagraph = true;
				}
			}
			// Code fence
			else if (m[5].charAt(0) === '`' || m[5].charAt(0) === '~')
			{
				tagPos = matchPos + ignoreLen;
				tagLen = lfPos - tagPos;

				if (codeTag && m[5] === codeFence)
				{
					endTag = addEndTag('CODE', tagPos, tagLen, -1);
					endTag.pairWith(codeTag);

					addIgnoreTag(textBoundary, tagPos - textBoundary);

					// Overwrite the whole block
					overwrite(codeTag.getPos(), tagPos + tagLen - codeTag.getPos());
					codeTag = null;
					codeFence = null;
				}
				else if (!codeTag)
				{
					// Create code block
					codeTag   = addStartTag('CODE', tagPos, tagLen);
					codeFence = m[5].replace(/[^`~]+/, '');
					codeTag.setAttribute('quoteDepth', quoteDepth);

					// Ignore the next character, which should be a newline
					addIgnoreTag(tagPos + tagLen, 1);

					// Add the language if present, e.g. ```php
					var lang = m[5].replace(/^[`~\s]*/, '').replace(/\s+$/, '');
					if (lang !== '')
					{
						codeTag.setAttribute('lang', lang);
					}
				}
			}
		}
		else if (m[3] && !listsCnt && text.charAt(matchPos + matchLen) !== "\x17")
		{
			// Horizontal rule
			addSelfClosingTag('HR', matchPos + ignoreLen, matchLen - ignoreLen);
			breakParagraph = true;

			// Mark the end of the line as a boundary
			markBoundary(lfPos);
		}
		else if (setextLines[lfPos] && setextLines[lfPos].quoteDepth === quoteDepth && !lineIsEmpty && !listsCnt && !codeTag)
		{
			// Setext-style header
			addTagPair(
				setextLines[lfPos].tagName,
				matchPos + ignoreLen,
				0,
				setextLines[lfPos].endTagPos,
				setextLines[lfPos].endTagLen
			);

			// Mark the end of the Setext line
			markBoundary(setextLines[lfPos].endTagPos + setextLines[lfPos].endTagLen);
		}

		if (breakParagraph)
		{
			addParagraphBreak(textBoundary);
			markBoundary(textBoundary);
		}

		if (!lineIsEmpty)
		{
			textBoundary = lfPos;
		}

		if (ignoreLen)
		{
			addIgnoreTag(matchPos, ignoreLen, 1000);
		}
	});
}

/**
* Match all forms of emphasis (emphasis and strong, using underscores or asterisks)
*/
function matchEmphasis()
{
	matchEmphasisByCharacter('*', /\*+/g);
	matchEmphasisByCharacter('_', /_+/g);
}

/**
* Match emphasis and strong applied using given character
*
* @param  {!string} character Markup character, either * or _
* @param  {!RegExp} regexp    Regexp used to match the series of emphasis character
*/
function matchEmphasisByCharacter(character, regexp)
{
	var pos = text.indexOf(character);
	if (pos === -1)
	{
		return;
	}

	getEmphasisByBlock(regexp, pos).forEach(processEmphasisBlock);
}

/**
* Match forced line break
*/
function matchForcedLineBreaks()
{
	var pos = text.indexOf("  \n");
	while (pos !== -1)
	{
		addBrTag(pos + 2);
		pos = text.indexOf("  \n", pos + 3);
	}
}

/**
* Match images markup
*/
function matchImages()
{
	var pos = text.indexOf('![');
	if (pos === -1)
	{
		return;
	}
	if (text.indexOf('](', pos) > 0)
	{
		matchInlineImages();
	}
	if (hasRefs)
	{
		matchReferenceImages();
	}
}

/**
* Match inline images markup
*/
function matchInlineImages()
{
	var m, regexp = /!\[(?:[^\x17[\]]|\[[^\x17[\]]*\])*\]\(( *(?:[^\x17\s()]|\([^\x17\s()]*\))*(?=[ )]) *(?:"[^\x17]*?"|'[^\x17]*?'|\([^\x17)]*\))? *)\)/g;
	while (m = regexp.exec(text))
	{
		var linkInfo    = m[1],
			startTagPos = m['index'],
			endTagLen   = 3 + linkInfo.length,
			endTagPos   = startTagPos + m[0].length - endTagLen,
			alt         = m[0].substr(2, m[0].length - endTagLen - 2);

		addImageTag(startTagPos, endTagPos, endTagLen, linkInfo, alt);
	}
}

/**
* Match reference images markup
*/
function matchReferenceImages()
{
	var m, regexp = /!\[((?:[^\x17[\]]|\[[^\x17[\]]*\])*)\](?: ?\[([^\x17[\]]+)\])?/g;
	while (m = regexp.exec(text))
	{
		var startTagPos = +m['index'],
			endTagPos   = startTagPos + 2 + m[1].length,
			endTagLen   = 1,
			alt         = m[1],
			id          = alt;

		if (m[2] > '' && refs[m[2]])
		{
			endTagLen = m[0].length - alt.length - 2;
			id        = m[2];
		}
		else if (!refs[id])
		{
			continue;
		}

		addImageTag(startTagPos, endTagPos, endTagLen, refs[id], alt);
	}
}

/**
* Match inline code spans
*/
function matchInlineCode()
{
	var markers = getInlineCodeMarkers(),
		i       = -1,
		cnt     = markers.length;
	while (++i < (cnt - 1))
	{
		var pos = markers[i].next,
			j   = i;
		if (text.charAt(markers[i].pos) !== '`')
		{
			// Adjust the left marker if its first backtick was escaped
			++markers[i].pos;
			--markers[i].len;
		}
		while (++j < cnt && markers[j].pos === pos)
		{
			if (markers[j].len === markers[i].len)
			{
				addInlineCodeTags(markers[i], markers[j]);
				i = j;
				break;
			}
			pos = markers[j].next;
		}
	}
}

/**
* Match inline links markup
*/
function matchInlineLinks()
{
	var m, regexp = /\[(?:[^\x17[\]]|\[[^\x17[\]]*\])*\]\(( *(?:[^\x17\s()]|\([^\x17\s()]*\))*(?=[ )]) *(?:"[^\x17]*?"|'[^\x17]*?'|\([^\x17)]*\))? *)\)/g;
	while (m = regexp.exec(text))
	{
		var linkInfo    = m[1],
			startTagPos = m['index'],
			endTagLen   = 3 + linkInfo.length,
			endTagPos   = startTagPos + m[0].length - endTagLen;

		addLinkTag(startTagPos, endTagPos, endTagLen, linkInfo);
	}
}

/**
* Capture link reference definitions in current text
*/
function matchLinkReferences()
{
	hasRefs = false;
	refs    = {};
	if (text.indexOf(']:') === -1)
	{
		return;
	}

	var m, regexp = /^\x1A* {0,3}\[([^\x17\]]+)\]: *([^\s\x17]+ *(?:"[^\x17]*?"|'[^\x17]*?'|\([^\x17)]*\))?)[^\x17\n]*\n?/gm;
	while (m = regexp.exec(text))
	{
		addIgnoreTag(m['index'], m[0].length, -2);

		// Ignore the reference if it already exists
		var id = m[1].toLowerCase();
		if (refs[id])
		{
			continue;
		}

		hasRefs  = true;
		refs[id] = m[2];
	}
}

/**
* Match inline and reference links
*/
function matchLinks()
{
	if (text.indexOf('](') !== -1)
	{
		matchInlineLinks();
	}
	if (hasRefs)
	{
		matchReferenceLinks();
	}
}

/**
* Match reference links markup
*/
function matchReferenceLinks()
{
	var labels = getLabels(), startTagPos;
	for (startTagPos in labels)
	{
		var id        = labels[startTagPos],
			labelPos  = +startTagPos + 2 + id.length,
			endTagPos = labelPos - 1,
			endTagLen = 1;

		if (text.charAt(labelPos) === ' ')
		{
			++labelPos;
		}
		if (labels[labelPos] > '' && refs[labels[labelPos]])
		{
			id        = labels[labelPos];
			endTagLen = labelPos + 2 + id.length - endTagPos;
		}
		if (refs[id])
		{
			addLinkTag(+startTagPos, endTagPos, endTagLen, refs[id]);
		}
	}
}

/**
* Match strikethrough
*/
function matchStrikethrough()
{
	if (text.indexOf('~~') === -1)
	{
		return;
	}

	var m, regexp = /~~[^\x17]+?~~/g;
	while (m = regexp.exec(text))
	{
		var match    = m[0],
			matchPos = m['index'],
			matchLen = match.length;

		addTagPair('DEL', matchPos, 2, matchPos + matchLen - 2, 2);
	}
}

/**
* Match superscript
*/
function matchSuperscript()
{
	if (text.indexOf('^') === -1)
	{
		return;
	}

	var m, regexp = /\^[^\x17\s]+/g;
	while (m = regexp.exec(text))
	{
		var match       = m[0],
			matchPos    = m['index'],
			matchLen    = match.length,
			startTagPos = matchPos,
			endTagPos   = matchPos + matchLen;

		var parts = match.split('^');
		parts.shift();

		parts.forEach(function(part)
		{
			addTagPair('SUP', startTagPos, 1, endTagPos, 0);
			startTagPos += 1 + part.length;
		});
	}
}

/**
* Overwrite part of the text with substitution characters ^Z (0x1A)
*
* @param  {!number} pos Start of the range
* @param  {!number} len Length of text to overwrite
*/
function overwrite(pos, len)
{
	text = text.substr(0, pos) + new Array(1 + len).join("\x1A") + text.substr(pos + len);
}

/**
* Process a list of emphasis markup strings
*
* @param {!Array<!Array<!number>>} block List of [matchPos, matchLen] pairs
*/
function processEmphasisBlock(block)
{
	var buffered  = 0,
		emPos     = -1,
		strongPos = -1,
		pair,
		remaining;

	block.forEach(function(pair)
	{
		var matchPos     = pair[0],
			matchLen     = pair[1],
			closeLen     = Math.min(3, matchLen),
			closeEm      = closeLen & buffered & 1,
			closeStrong  = closeLen & buffered & 2,
			emEndPos     = matchPos,
			strongEndPos = matchPos;

		if (buffered > 2 && emPos === strongPos)
		{
			if (closeEm)
			{
				emPos += 2;
			}
			else
			{
				++strongPos;
			}
		}

		if (closeEm && closeStrong)
		{
			if (emPos < strongPos)
			{
				emEndPos += 2;
			}
			else
			{
				++strongEndPos;
			}
		}

		remaining = matchLen;
		if (closeEm)
		{
			--buffered;
			--remaining;
			addTagPair('EM', emPos, 1, emEndPos, 1);
		}
		if (closeStrong)
		{
			buffered  -= 2;
			remaining -= 2;
			addTagPair('STRONG', strongPos, 2, strongEndPos, 2);
		}

		remaining = Math.min(3, remaining);
		if (remaining & 1)
		{
			emPos = matchPos + matchLen - remaining;
		}
		if (remaining & 2)
		{
			strongPos = matchPos + matchLen - remaining;
		}
		buffered += remaining;
	});
}

/**
* Set a URL or IMG tag's attributes
*
* @param {!Tag}    tag      URL or IMG tag
* @param {!string} linkInfo Link's info: an URL optionally followed by spaces and a title
* @param {!string} attrName Name of the URL attribute
*/
function setLinkAttributes(tag, linkInfo, attrName)
{
	var url   = linkInfo.replace(/^\s*/, '').replace(/\s*$/, ''),
		title = '',
		pos   = url.indexOf(' ')
	if (pos !== -1)
	{
		title = url.substr(pos).replace(/^\s*\S/, '').replace(/\S\s*$/, '');
		url   = url.substr(0, pos);
	}

	tag.setAttribute(attrName, decode(url));
	if (title > '')
	{
		tag.setAttribute('title', decode(title));
	}
}
				}},"MediaEmbed":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={tagName:"MEDIA"};
					matches.forEach(function(m)
{
	var url = m[0][0],
		pos = m[0][1],
		len = url.length,
		// Give that tag priority over other tags such as Autolink's
		tag = addSelfClosingTag(config.tagName, pos, len, -10);

	tag.setAttribute('url', url);
});
				},quickMatch:":",regexp:/\b(?:spotify:|https?:\/\/)[^["'\s]+/ig,regexpLimit:50000}};

/**
* @type {!number} Position of the cursor in the original text
*/
var pos;

/**
* @type {!Object} Variables registered for use in filters
*/
var registeredVars={"mediasites":{"8tracks.com":"eighttracks","abcnews.go.com":"abcnews","amazon.ca":"amazon","amazon.co.jp":"amazon","amazon.co.uk":"amazon","amazon.com":"amazon","amazon.de":"amazon","amazon.es":"amazon","amazon.fr":"amazon","amazon.in":"amazon","amazon.it":"amazon","archive.org":"internetarchive","audioboo.fm":"audioboom","audioboom.com":"audioboom","audiomack.com":"audiomack","bandcamp.com":"bandcamp","bbc.com":"bbcnews","bcove.me":"brightcove","blab.im":"blab","bleacherreport.com":"bleacherreport","break.com":"break","cbsnews.com":"cbsnews","cc.com":"comedycentral","channel.nationalgeographic.com":"natgeochannel","cnn.com":"cnn","collegehumor.com":"collegehumor","comedycentral.com":"comedycentral","coub.com":"coub","dailymotion.com":"dailymotion","democracynow.org":"democracynow","docs.google.com":"googlesheets","drive.google.com":"googledrive","dumpert.nl":"dumpert","espn.com":"espn","espn.go.com":"espn","facebook.com":"facebook","flickr.com":"flickr","fora.tv":"foratv","funnyordie.com":"funnyordie","gamespot.com":"gamespot","gametrailers.com":"gametrailers","gettyimages.be":"getty","gettyimages.cn":"getty","gettyimages.co.jp":"getty","gettyimages.co.uk":"getty","gettyimages.com":"getty","gettyimages.com.au":"getty","gettyimages.de":"getty","gettyimages.dk":"getty","gettyimages.es":"getty","gettyimages.fr":"getty","gettyimages.ie":"getty","gettyimages.it":"getty","gettyimages.nl":"getty","gettyimages.pt":"getty","gettyimages.se":"getty","gfycat.com":"gfycat","gifs.com":"gifs","github.com":"gist","globalnews.ca":"globalnews","gofundme.com":"gofundme","gty.im":"getty","healthguru.com":"healthguru","hudl.com":"hudl","hulu.com":"hulu","humortv.vara.nl":"humortvnl","ign.com":"ign","imdb.com":"imdb","imgur.com":"imgur","indiegogo.com":"indiegogo","instagram.com":"instagram","izlesene.com":"izlesene","jwplatform.com":"jwplatform","kickstarter.com":"kickstarter","kissvideo.click":"kissvideo","libsyn.com":"libsyn","link.brightcove.com":"brightcove","livecap.tv":"livecap","liveleak.com":"liveleak","livestre.am":"livestream","livestream.com":"livestream","medium.com":"medium","metacafe.com":"metacafe","mixcloud.com":"mixcloud","mlb.com":"mlb","money.cnn.com":"cnnmoney","mrctv.org":"mrctv","msnbc.com":"msnbc","my.mail.ru":"mailru","n.pr":"npr","nbcnews.com":"nbcnews","nbcsports.com":"nbcsports","nhl.com":"nhl","npr.org":"npr","nytimes.com":"nytimes","oddshot.tv":"oddshot","open.spotify.com":"spotify","pastebin.com":"pastebin","pinterest.com":"pinterest","play.spotify.com":"spotify","plays.tv":"playstv","plus.google.com":"googleplus","podbean.com":"podbean","prezi.com":"prezi","reddit.com":"reddit","rutube.ru":"rutube","screen.yahoo.com":"yahooscreen","scribd.com":"scribd","slideshare.net":"slideshare","soundcloud.com":"soundcloud","sportsnet.ca":"sportsnet","spotify:":"spotify","stitcher.com":"stitcher","store.steampowered.com":"steamstore","strawpoll.me":"strawpoll","streamable.com":"streamable","teamcoco.com":"teamcoco","ted.com":"ted","theatlantic.com":"theatlantic","theguardian.com":"theguardian","theonion.com":"theonion","tinypic.com":"tinypic","tmz.com":"tmz","traileraddict.com":"traileraddict","tumblr.com":"tumblr","twitch.tv":"twitch","twitter.com":"twitter","ustream.tv":"ustream","vbox7.com":"vbox7","veoh.com":"veoh","vevo.com":"vevo","viagame.com":"viagame","vid.me":"vidme","video.cnbc.com":"cnbc","video.foxnews.com":"foxnews","video.khl.ru":"khl","video.nationalgeographic.com":"natgeovideo","videodetective.com":"videodetective","videomega.tv":"videomega","vimeo.com":"vimeo","vine.co":"vine","vk.com":"vk","vkontakte.ru":"vk","vocaroo.com":"vocaroo","vox.com":"vox","washingtonpost.com":"washingtonpost","worldstarhiphop.com":"wshh","wsj.com":"wsj","xboxclips.com":"xboxclips","xboxdvr.com":"xboxdvr","youku.com":"youku","youtu.be":"youtube","youtube.com":"youtube","zippyshare.com":"zippyshare"},"urlConfig":{allowedSchemes:/^https?$/i}};

/**
* @type {!Object} Root context, used at the root of the document
*/
var rootContext={allowed:[0],flags:32};

/**
* @type {!Object} Tags' config
* @const
*/
var tagsConfig={};

/**
* @type {!Array.<!Tag>} Tag storage
*/
var tagStack;

/**
* @type {!boolean} Whether the tags in the stack are sorted
*/
var tagStackIsSorted;

/**
* @type {!string} Text being parsed
*/
var text;

/**
* @type {!number} Length of the text being parsed
*/
var textLen;

/**
* @type {!number} Counter incremented everytime the parser is reset. Used to as a canary to detect
*                 whether the parser was reset during execution
*/
var uid = 0;

/**
* @type {!number} Position before which we output text verbatim, without paragraphs or linebreaks
*/
var wsPos;

//==========================================================================
// Public API
//==========================================================================

/**
* Disable a tag
*
* @param {!string} tagName Name of the tag
*/
function disableTag(tagName)
{
	if (tagsConfig[tagName])
	{
		copyTagConfig(tagName).isDisabled = true;
	}
}

/**
* Enable a tag
*
* @param {!string} tagName Name of the tag
*/
function enableTag(tagName)
{
	if (tagsConfig[tagName])
	{
		copyTagConfig(tagName).isDisabled = false;
	}
}

/**
* Get this parser's Logger instance
*
* @return {!Logger}
*/
function getLogger()
{
	return logger;
}

/**
* Parse a text
*
* @param  {!string} _text Text to parse
* @return {!string}       XML representation
*/
function parse(_text)
{
	// Reset the parser and save the uid
	reset(_text);
	var _uid = uid;

	// Do the heavy lifting
	executePluginParsers();
	processTags();

	// Finalize the document
	finalizeOutput();

	// Check the uid in case a plugin or a filter reset the parser mid-execution
	if (uid !== _uid)
	{
		throw 'The parser has been reset during execution';
	}

	// Log a warning if the fixing cost limit was exceeded
	if (currentFixingCost > maxFixingCost)
	{
		logger.warn('Fixing cost limit exceeded');
	}

	return output;
}

/**
* Reset the parser for a new parsing
*
* @param {!string} _text Text to be parsed
*/
function reset(_text)
{
	// Normalize CR/CRLF to LF, remove control characters that aren't allowed in XML
	_text = _text.replace(/\r\n?/g, "\n");
	_text = _text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]+/g, '');

	// Clear the logs
	logger.clear();

	// Initialize the rest
	cntOpen           = {};
	cntTotal          = {};
	currentFixingCost = 0;
	currentTag        = null;
	isRich            = false;
	namespaces        = {};
	openTags          = [];
	output            = '';
	pos               = 0;
	tagStack          = [];
	tagStackIsSorted  = false;
	text              = _text;
	textLen           = text.length;
	wsPos             = 0;

	// Initialize the root context
	context = rootContext;
	context.inParagraph = false;

	// Bump the UID
	++uid;
}

/**
* Change a tag's tagLimit
*
* NOTE: the default tagLimit should generally be set during configuration instead
*
* @param {!string} tagName  The tag's name, in UPPERCASE
* @param {!number} tagLimit
*/
function setTagLimit(tagName, tagLimit)
{
	if (tagsConfig[tagName])
	{
		copyTagConfig(tagName).tagLimit = tagLimit;
	}
}

/**
* Change a tag's nestingLimit
*
* NOTE: the default nestingLimit should generally be set during configuration instead
*
* @param {!string} tagName      The tag's name, in UPPERCASE
* @param {!number} nestingLimit
*/
function setNestingLimit(tagName, nestingLimit)
{
	if (tagsConfig[tagName])
	{
		copyTagConfig(tagName).nestingLimit = nestingLimit;
	}
}

/**
* Copy a tag's config
*
* This method ensures that the tag's config is its own object and not shared with another
* identical tag
*
* @param  {!string} tagName Tag's name
* @return {!Object}         Tag's config
*/
function copyTagConfig(tagName)
{
	var tagConfig = {}, k;
	for (k in tagsConfig[tagName])
	{
		tagConfig[k] = tagsConfig[tagName][k];
	}

	return tagsConfig[tagName] = tagConfig;
}

//==========================================================================
// Filter processing
//==========================================================================

/**
* Execute all the attribute preprocessors of given tag
*
* @private
*
* @param  {!Tag}     tag       Source tag
* @param  {!Object}  tagConfig Tag's config
* @return {!boolean}           Unconditionally TRUE
*/
function executeAttributePreprocessors(tag, tagConfig)
{
	if (tagConfig.attributePreprocessors)
	{
		tagConfig.attributePreprocessors.forEach(function(attributePreprocessor)
		{
			var attrName = attributePreprocessor[0],
				regexp   = attributePreprocessor[1],
				map      = attributePreprocessor[2];

			if (!tag.hasAttribute(attrName))
			{
				return;
			}

			executeAttributePreprocessor(tag, attrName, regexp, map);
		});
	}

	return true;
}

/**
* Execute an attribute preprocessor
*
* @param  {!Tag}            tag
* @param  {!string}         attrName
* @param  {!string}         regexp
* @param  {!Array<!string>} map
*/
function executeAttributePreprocessor(tag, attrName, regexp, map)
{
	var attrValue = tag.getAttribute(attrName),
		captures  = getNamedCaptures(attrValue, regexp, map),
		k;
	
	for (k in captures)
	{
		// Attribute preprocessors cannot overwrite other attributes but they can
		// overwrite themselves
		if (k === attrName || !tag.hasAttribute(k))
		{
			tag.setAttribute(k, captures[k]);
		}
	}
}

/**
* Execute a regexp and return the values of the mapped captures
*
* @param  {!string}                  attrValue
* @param  {!string}                  regexp
* @param  {!Array<!string>}          map
* @return {!Object<!string,!string>}
*/
function getNamedCaptures(attrValue, regexp, map)
{
	var m = regexp.exec(attrValue);
	if (!m)
	{
		return [];
	}

	var values = {};
	map.forEach(function(k, i)
	{
		if (typeof m[i] === 'string' && m[i] !== '')
		{
			values[k] = m[i];
		}
	});

	return values;
}

/**
* Filter the attributes of given tag
*
* @private
*
* @param  {!Tag}     tag            Tag being checked
* @param  {!Object}  tagConfig      Tag's config
* @param  {!Object}  registeredVars Vars registered for use in attribute filters
* @param  {!Logger}  logger         This parser's Logger instance
* @return {!boolean}           Whether the whole attribute set is valid
*/
function filterAttributes(tag, tagConfig, registeredVars, logger)
{
	if (!tagConfig.attributes)
	{
		tag.setAttributes({});

		return true;
	}

	var attrName, attrConfig;

	// Generate values for attributes with a generator set
	if (HINT.attributeGenerator)
	{
		for (attrName in tagConfig.attributes)
		{
			attrConfig = tagConfig.attributes[attrName];

			if (attrConfig.generator)
			{
				tag.setAttribute(attrName, attrConfig.generator(attrName));
			}
		}
	}

	// Filter and remove invalid attributes
	var attributes = tag.getAttributes();
	for (attrName in attributes)
	{
		var attrValue = attributes[attrName];

		// Test whether this attribute exists and remove it if it doesn't
		if (!tagConfig.attributes[attrName])
		{
			tag.removeAttribute(attrName);
			continue;
		}

		attrConfig = tagConfig.attributes[attrName];

		// Test whether this attribute has a filterChain
		if (!attrConfig.filterChain)
		{
			continue;
		}

		// Record the name of the attribute being filtered into the logger
		logger.setAttribute(attrName);

		for (var i = 0; i < attrConfig.filterChain.length; ++i)
		{
			// NOTE: attrValue is intentionally set as the first argument to facilitate inlining
			attrValue = attrConfig.filterChain[i](attrValue, attrName);

			if (attrValue === false)
			{
				tag.removeAttribute(attrName);
				break;
			}
		}

		// Update the attribute value if it's valid
		if (attrValue !== false)
		{
			tag.setAttribute(attrName, attrValue);
		}

		// Remove the attribute's name from the logger
		logger.unsetAttribute();
	}

	// Iterate over the attribute definitions to handle missing attributes
	for (attrName in tagConfig.attributes)
	{
		attrConfig = tagConfig.attributes[attrName];

		// Test whether this attribute is missing
		if (!tag.hasAttribute(attrName))
		{
			if (HINT.attributeDefaultValue && attrConfig.defaultValue !== undefined)
			{
				// Use the attribute's default value
				tag.setAttribute(attrName, attrConfig.defaultValue);
			}
			else if (attrConfig.required)
			{
				// This attribute is missing, has no default value and is required, which means
				// the attribute set is invalid
				return false;
			}
		}
	}

	return true;
}

/**
* Execute given tag's filterChain
*
* @param  {!Tag}     tag Tag to filter
* @return {!boolean}     Whether the tag is valid
*/
function filterTag(tag)
{
	var tagName   = tag.getName(),
		tagConfig = tagsConfig[tagName],
		isValid   = true;

	if (tagConfig.filterChain)
	{
		// Record the tag being processed into the logger it can be added to the context of
		// messages logged during the execution
		logger.setTag(tag);

		for (var i = 0; i < tagConfig.filterChain.length; ++i)
		{
			if (!tagConfig.filterChain[i](tag, tagConfig))
			{
				isValid = false;
				break;
			}
		}

		// Remove the tag from the logger
		logger.unsetTag();
	}

	return isValid;
}

//==========================================================================
// Output handling
//==========================================================================

/**
* Replace Unicode characters outside the BMP with XML entities in the output
*/
function encodeUnicodeSupplementaryCharacters()
{
	output = output.replace(
		/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
		encodeUnicodeSupplementaryCharactersCallback
	);
}

/**
* Encode given surrogate pair into an XML entity
*
* @param  {!string} pair Surrogate pair
* @return {!string}      XML entity
*/
function encodeUnicodeSupplementaryCharactersCallback(pair)
{
	var cp = (pair.charCodeAt(0) << 10) + pair.charCodeAt(1) - 56613888;

	return '&#' + cp + ';';
}

/**
* Finalize the output by appending the rest of the unprocessed text and create the root node
*/
function finalizeOutput()
{
	var tmp;

	// Output the rest of the text and close the last paragraph
	outputText(textLen, 0, true);

	// Remove empty tag pairs, e.g. <I><U></U></I> as well as empty paragraphs
	do
	{
		tmp = output;
		output = output.replace(/<([^ />]+)[^>]*><\/\1>/g, '');
	}
	while (output !== tmp);

	// Merge consecutive <i> tags
	output = output.replace(/<\/i><i>/g, '', output);

	// Encode Unicode characters that are outside of the BMP
	encodeUnicodeSupplementaryCharacters();

	// Use a <r> root if the text is rich, or <t> for plain text (including <p></p> and <br/>)
	var tagName = (isRich) ? 'r' : 't';

	// Prepare the root node with all the namespace declarations
	tmp = '<' + tagName;
	if (HINT.namespaces)
	{
		for (var prefix in namespaces)
		{
			tmp += ' xmlns:' + prefix + '="urn:s9e:TextFormatter:' + prefix + '"';
		}
	}

	output = tmp + '>' + output + '</' + tagName + '>';
}

/**
* Append a tag to the output
*
* @param {!Tag} tag Tag to append
*/
function outputTag(tag)
{
	isRich = true;

	var tagName    = tag.getName(),
		tagPos     = tag.getPos(),
		tagLen     = tag.getLen(),
		tagFlags   = tag.getFlags(),
		skipBefore = 0,
		skipAfter  = 0;

	if (HINT.RULE_IGNORE_WHITESPACE && (tagFlags & RULE_IGNORE_WHITESPACE))
	{
		skipBefore = 1;
		skipAfter  = (tag.isEndTag()) ? 2 : 1;
	}

	// Current paragraph must end before the tag if:
	//  - the tag is a start (or self-closing) tag and it breaks paragraphs, or
	//  - the tag is an end tag (but not self-closing)
	var closeParagraph = false;
	if (tag.isStartTag())
	{
		if (HINT.RULE_BREAK_PARAGRAPH && (tagFlags & RULE_BREAK_PARAGRAPH))
		{
			closeParagraph = true;
		}
	}
	else
	{
		closeParagraph = true;
	}

	// Let the cursor catch up with this tag's position
	outputText(tagPos, skipBefore, closeParagraph);

	// Capture the text consumed by the tag
	var tagText = (tagLen)
				? htmlspecialchars_noquotes(text.substr(tagPos, tagLen))
				: '';

	// Output current tag
	if (tag.isStartTag())
	{
		// Handle paragraphs before opening the tag
		if (!HINT.RULE_BREAK_PARAGRAPH || !(tagFlags & RULE_BREAK_PARAGRAPH))
		{
			outputParagraphStart(tagPos);
		}

		// Record this tag's namespace, if applicable
		if (HINT.namespaces)
		{
			var colonPos = tagName.indexOf(':');
			if (colonPos > 0)
			{
				namespaces[tagName.substr(0, colonPos)] = 0;
			}
		}

		// Open the start tag and add its attributes, but don't close the tag
		output += '<' + tagName;

		// We output the attributes in lexical order. Helps canonicalizing the output and could
		// prove useful someday
		var attributes = tag.getAttributes(),
			attributeNames = [];
		for (var attrName in attributes)
		{
			attributeNames.push(attrName);
		}
		attributeNames.sort(
			function(a, b)
			{
				return (a > b) ? 1 : -1;
			}
		);
		attributeNames.forEach(
			function(attrName)
			{
				output += ' ' + attrName + '="' + htmlspecialchars_compat(attributes[attrName].toString()).replace(/\n/g, '&#10;') + '"';
			}
		);

		if (tag.isSelfClosingTag())
		{
			if (tagLen)
			{
				output += '>' + tagText + '</' + tagName + '>';
			}
			else
			{
				output += '/>';
			}
		}
		else if (tagLen)
		{
			output += '><s>' + tagText + '</s>';
		}
		else
		{
			output += '>';
		}
	}
	else
	{
		if (tagLen)
		{
			output += '<e>' + tagText + '</e>';
		}

		output += '</' + tagName + '>';
	}

	// Move the cursor past the tag
	pos = tagPos + tagLen;

	// Skip newlines (no other whitespace) after this tag
	wsPos = pos;
	while (skipAfter && wsPos < textLen && text.charAt(wsPos) === "\n")
	{
		// Decrement the number of lines to skip
		--skipAfter;

		// Move the cursor past the newline
		++wsPos;
	}
}

/**
* Output the text between the cursor's position (included) and given position (not included)
*
* @param  {!number}  catchupPos     Position we're catching up to
* @param  {!number}  maxLines       Maximum number of lines to ignore at the end of the text
* @param  {!boolean} closeParagraph Whether to close the paragraph at the end, if applicable
*/
function outputText(catchupPos, maxLines, closeParagraph)
{
	if (closeParagraph)
	{
		if (!(context.flags & RULE_CREATE_PARAGRAPHS))
		{
			closeParagraph = false;
		}
		else
		{
			// Ignore any number of lines at the end if we're closing a paragraph
			maxLines = -1;
		}
	}

	if (pos >= catchupPos)
	{
		// We're already there, close the paragraph if applicable and return
		if (closeParagraph)
		{
			outputParagraphEnd();
		}
	}

	// Skip over previously identified whitespace if applicable
	if (wsPos > pos)
	{
		var skipPos = Math.min(catchupPos, wsPos);
		output += text.substr(pos, skipPos - pos);
		pos = skipPos;

		if (pos >= catchupPos)
		{
			// Skipped everything. Close the paragraph if applicable and return
			if (closeParagraph)
			{
				outputParagraphEnd();
			}
		}
	}

	var catchupLen, catchupText;

	// Test whether we're even supposed to output anything
	if (HINT.RULE_IGNORE_TEXT && context.flags & RULE_IGNORE_TEXT)
	{
		catchupLen  = catchupPos - pos,
		catchupText = text.substr(pos, catchupLen);

		// If the catchup text is not entirely composed of whitespace, we put it inside ignore tags
		if (!/^[ \n\t]*$/.test(catchupText))
		{
			catchupText = '<i>' + catchupText + '</i>';
		}

		output += catchupText;
		pos = catchupPos;

		if (closeParagraph)
		{
			outputParagraphEnd();
		}

		return;
	}

	// Compute the amount of text to ignore at the end of the output
	var ignorePos = catchupPos,
		ignoreLen = 0;

	// Ignore as many lines (including whitespace) as specified
	while (maxLines && --ignorePos >= pos)
	{
		var c = text.charAt(ignorePos);
		if (c !== ' ' && c !== "\n" && c !== "\t")
		{
			break;
		}

		if (c === "\n")
		{
			--maxLines;
		}

		++ignoreLen;
	}

	// Adjust catchupPos to ignore the text at the end
	catchupPos -= ignoreLen;

	// Break down the text in paragraphs if applicable
	if (HINT.RULE_CREATE_PARAGRAPHS && context.flags & RULE_CREATE_PARAGRAPHS)
	{
		if (!context.inParagraph)
		{
			outputWhitespace(catchupPos);

			if (catchupPos > pos)
			{
				outputParagraphStart(catchupPos);
			}
		}

		// Look for a paragraph break in this text
		var pbPos = text.indexOf("\n\n", pos);

		while (pbPos > -1 && pbPos < catchupPos)
		{
			outputText(pbPos, 0, true);
			outputParagraphStart(catchupPos);

			pbPos = text.indexOf("\n\n", pos);
		}
	}

	// Capture, escape and output the text
	if (catchupPos > pos)
	{
		catchupText = htmlspecialchars_noquotes(
			text.substr(pos, catchupPos - pos)
		);

		// Format line breaks if applicable
		if (HINT.RULE_ENABLE_AUTO_BR && (context.flags & RULES_AUTO_LINEBREAKS) === RULE_ENABLE_AUTO_BR)
		{
			catchupText = catchupText.replace(/\n/g, "<br/>\n");
		}

		output += catchupText;
	}

	// Close the paragraph if applicable
	if (closeParagraph)
	{
		outputParagraphEnd();
	}

	// Add the ignored text if applicable
	if (ignoreLen)
	{
		output += text.substr(catchupPos, ignoreLen);
	}

	// Move the cursor past the text
	pos = catchupPos + ignoreLen;
}

/**
* Output a linebreak tag
*
* @param  {!Tag} tag
* @return void
*/
function outputBrTag(tag)
{
	outputText(tag.getPos(), 0, false);
	output += '<br/>';
}

/**
* Output an ignore tag
*
* @param  {!Tag} tag
* @return void
*/
function outputIgnoreTag(tag)
{
	var tagPos = tag.getPos(),
		tagLen = tag.getLen();

	// Capture the text to ignore
	var ignoreText = text.substr(tagPos, tagLen);

	// Catch up with the tag's position then output the tag
	outputText(tagPos, 0, false);
	output += '<i>' + htmlspecialchars_noquotes(ignoreText) + '</i>';
	isRich = true;

	// Move the cursor past this tag
	pos = tagPos + tagLen;
}

/**
* Start a paragraph between current position and given position, if applicable
*
* @param  {!number} maxPos Rightmost position at which the paragraph can be opened
*/
function outputParagraphStart(maxPos)
{
	if (!HINT.RULE_CREATE_PARAGRAPHS)
	{
		return;
	}

	// Do nothing if we're already in a paragraph, or if we don't use paragraphs
	if (context.inParagraph
	 || !(context.flags & RULE_CREATE_PARAGRAPHS))
	{
		return;
	}

	// Output the whitespace between pos and maxPos if applicable
	outputWhitespace(maxPos);

	// Open the paragraph, but only if it's not at the very end of the text
	if (pos < textLen)
	{
		output += '<p>';
		context.inParagraph = true;
	}
}

/**
* Close current paragraph at current position if applicable
*/
function outputParagraphEnd()
{
	// Do nothing if we're not in a paragraph
	if (!context.inParagraph)
	{
		return;
	}

	output += '</p>';
	context.inParagraph = false;
}

/**
* Output the content of a verbatim tag
*
* @param {!Tag} tag
*/
function outputVerbatim(tag)
{
	var flags = context.flags;
	context.flags = tag.getFlags();
	outputText(currentTag.getPos() + currentTag.getLen(), 0, false);
	context.flags = flags;
}

/**
* Skip as much whitespace after current position as possible
*
* @param  {!number} maxPos Rightmost character to be skipped
*/
function outputWhitespace(maxPos)
{
	while (pos < maxPos && " \n\t".indexOf(text.charAt(pos)) > -1)
	{
		output += text.charAt(pos);
		++pos;
	}
}

//==========================================================================
// Plugins handling
//==========================================================================

/**
* Disable a plugin
*
* @param {!string} pluginName Name of the plugin
*/
function disablePlugin(pluginName)
{
	if (plugins[pluginName])
	{
		plugins[pluginName].isDisabled = true;
	}
}

/**
* Enable a plugin
*
* @param {!string} pluginName Name of the plugin
*/
function enablePlugin(pluginName)
{
	if (plugins[pluginName])
	{
		plugins[pluginName].isDisabled = false;
	}
}

/**
* Execute given plugin
*
* @param {!string} pluginName Plugin's name
*/
function executePluginParser(pluginName)
{
	var pluginConfig = plugins[pluginName];
	if (pluginConfig.quickMatch && text.indexOf(pluginConfig.quickMatch) < 0)
	{
		return;
	}

	var matches = [];
	if (pluginConfig.regexp)
	{
		matches = getMatches(pluginConfig.regexp, pluginConfig.regexpLimit);
		if (!matches.length)
		{
			return;
		}
	}

	// Execute the plugin's parser, which will add tags via addStartTag() and others
	getPluginParser(pluginName)(text, matches);
}

/**
* Execute all the plugins
*/
function executePluginParsers()
{
	for (var pluginName in plugins)
	{
		if (!plugins[pluginName].isDisabled)
		{
			executePluginParser(pluginName);
		}
	}
}

/**
* Get regexp matches in a manner similar to preg_match_all() with PREG_SET_ORDER | PREG_OFFSET_CAPTURE
*
* @param  {!RegExp} regexp
* @param  {!number} limit
* @return {!Array.<!Array>}
*/
function getMatches(regexp, limit)
{
	// Reset the regexp
	regexp.lastIndex = 0;
	var matches = [], cnt = 0, m;
	while (++cnt <= limit && (m = regexp.exec(text)))
	{
		// NOTE: coercing m.index to a number because Closure Compiler thinks pos is a string otherwise
		var pos   = +m['index'],
			match = [[m[0], pos]],
			i = 0;
		while (++i < m.length)
		{
			var str = m[i];

			// Sub-expressions that were not evaluated return undefined
			if (str === undefined)
			{
				match.push(['', -1]);
			}
			else
			{
				match.push([str, text.indexOf(str, pos)]);
				pos += str.length;
			}
		}

		matches.push(match);
	}

	return matches;
}

/**
* Get the callback for given plugin's parser
*
* @param  {!string}   pluginName
* @return {!function(string, Array)}
*/
function getPluginParser(pluginName)
{
	return plugins[pluginName].parser;
}

/**
* Register a parser
*
* Can be used to add a new parser with no plugin config, or pre-generate a parser for an
* existing plugin
*
* @param  {!string}   pluginName
* @param  {!Function} parser
* @param  {RegExp}   regexp
* @param  {number}   limit
*/
function registerParser(pluginName, parser, regexp, limit)
{
	// Create an empty config for this plugin to ensure it is executed
	if (!plugins[pluginName])
	{
		plugins[pluginName] = {};
	}
	if (regexp)
	{
		plugins[pluginName].regexp = regexp;
		plugins[pluginName].limit  = limit || Infinity;
	}
	plugins[pluginName].parser = parser;
}

//==========================================================================
// Rules handling
//==========================================================================

/**
* Apply closeAncestor rules associated with given tag
*
* @param  {!Tag}     tag Tag
* @return {!boolean}     Whether a new tag has been added
*/
function closeAncestor(tag)
{
	if (!HINT.closeAncestor)
	{
		return false;
	}

	if (openTags.length)
	{
		var tagName   = tag.getName(),
			tagConfig = tagsConfig[tagName];

		if (tagConfig.rules.closeAncestor)
		{
			var i = openTags.length;

			while (--i >= 0)
			{
				var ancestor     = openTags[i],
					ancestorName = ancestor.getName();

				if (tagConfig.rules.closeAncestor[ancestorName])
				{
					++currentFixingCost;

					// We have to close this ancestor. First we reinsert this tag...
					tagStack.push(tag);

					// ...then we add a new end tag for it with a better priority
					addMagicEndTag(ancestor, tag.getPos(), tag.getSortPriority() - 1);

					return true;
				}
			}
		}
	}

	return false;
}

/**
* Apply closeParent rules associated with given tag
*
* @param  {!Tag}     tag Tag
* @return {!boolean}     Whether a new tag has been added
*/
function closeParent(tag)
{
	if (!HINT.closeParent)
	{
		return false;
	}

	if (openTags.length)
	{
		var tagName   = tag.getName(),
			tagConfig = tagsConfig[tagName];

		if (tagConfig.rules.closeParent)
		{
			var parent     = openTags[openTags.length - 1],
				parentName = parent.getName();

			if (tagConfig.rules.closeParent[parentName])
			{
				++currentFixingCost;

				// We have to close that parent. First we reinsert the tag...
				tagStack.push(tag);

				// ...then we add a new end tag for it with a better priority
				addMagicEndTag(parent, tag.getPos(), tag.getSortPriority() - 1);

				return true;
			}
		}
	}

	return false;
}

/**
* Apply the createChild rules associated with given tag
*
* @param {!Tag} tag Tag
*/
function createChild(tag)
{
	if (!HINT.createChild)
	{
		return;
	}

	var tagConfig = tagsConfig[tag.getName()];
	if (tagConfig.rules.createChild)
	{
		var priority = -1000,
			_text    = text.substr(pos),
			tagPos   = pos + _text.length - _text.replace(/^[ \n\r\t]+/, '').length;
		tagConfig.rules.createChild.forEach(function(tagName)
		{
			addStartTag(tagName, tagPos, 0, ++priority);
		});
	}
}

/**
* Apply fosterParent rules associated with given tag
*
* NOTE: this rule has the potential for creating an unbounded loop, either if a tag tries to
*       foster itself or two or more tags try to foster each other in a loop. We mitigate the
*       risk by preventing a tag from creating a child of itself (the parent still gets closed)
*       and by checking and increasing the currentFixingCost so that a loop of multiple tags
*       do not run indefinitely. The default tagLimit and nestingLimit also serve to prevent the
*       loop from running indefinitely
*
* @param  {!Tag}     tag Tag
* @return {!boolean}     Whether a new tag has been added
*/
function fosterParent(tag)
{
	if (!HINT.fosterParent)
	{
		return false;
	}

	if (openTags.length)
	{
		var tagName   = tag.getName(),
			tagConfig = tagsConfig[tagName];

		if (tagConfig.rules.fosterParent)
		{
			var parent     = openTags[openTags.length - 1],
				parentName = parent.getName();

			if (tagConfig.rules.fosterParent[parentName])
			{
				if (parentName !== tagName && currentFixingCost < maxFixingCost)
				{
					addFosterTag(tag, parent)
				}

				// Reinsert current tag
				tagStack.push(tag);

				// And finally close its parent with a priority that ensures it is processed
				// before this tag
				addMagicEndTag(parent, tag.getPos(), tag.getSortPriority() - 1);

				// Adjust the fixing cost to account for the additional tags/processing
				currentFixingCost += 4;

				return true;
			}
		}
	}

	return false;
}

/**
* Apply requireAncestor rules associated with given tag
*
* @param  {!Tag}     tag Tag
* @return {!boolean}     Whether this tag has an unfulfilled requireAncestor requirement
*/
function requireAncestor(tag)
{
	if (!HINT.requireAncestor)
	{
		return false;
	}

	var tagName   = tag.getName(),
		tagConfig = tagsConfig[tagName];

	if (tagConfig.rules.requireAncestor)
	{
		var i = tagConfig.rules.requireAncestor.length;
		while (--i >= 0)
		{
			var ancestorName = tagConfig.rules.requireAncestor[i];
			if (cntOpen[ancestorName])
			{
				return false;
			}
		}

		logger.err('Tag requires an ancestor', {
			'requireAncestor' : tagConfig.rules.requireAncestor.join(', '),
			'tag'             : tag
		});

		return true;
	}

	return false;
}

//==========================================================================
// Tag processing
//==========================================================================

/**
* Create and add a copy of a tag as a child of a given tag
*
* @param {!Tag} tag       Current tag
* @param {!Tag} fosterTag Tag to foster
*/
function addFosterTag(tag, fosterTag)
{
	var coords    = getMagicStartCoords(tag.getPos() + tag.getLen()),
		childPos  = coords[0],
		childPrio = coords[1];

	// Add a 0-width copy of the parent tag after this tag and make it depend on this tag
	var childTag = addCopyTag(fosterTag, childPos, 0, childPrio);
	tag.cascadeInvalidationTo(childTag);
}

/**
* Create and add an end tag for given start tag at given position
*
* @param  {!Tag}    startTag Start tag
* @param  {!number} tagPos   End tag's position (will be adjusted for whitespace if applicable)
* @return {!Tag}
*/
function addMagicEndTag(startTag, tagPos)
{
	var tagName = startTag.getName();

	// Adjust the end tag's position if whitespace is to be minimized
	if (HINT.RULE_IGNORE_WHITESPACE && ((currentTag.getFlags() | startTag.getFlags()) & RULE_IGNORE_WHITESPACE))
	{
		tagPos = getMagicEndPos(tagPos);
	}

	// Add a 0-width end tag that is paired with the given start tag
	var endTag = addEndTag(tagName, tagPos, 0);
	endTag.pairWith(startTag);

	return endTag;
}

/**
* Compute the position of a magic end tag, adjusted for whitespace
*
* @param  {!number} tagPos Rightmost possible position for the tag
* @return {!number}
*/
function getMagicEndPos(tagPos)
{
	// Back up from given position to the cursor's position until we find a character that
	// is not whitespace
	while (tagPos > pos && WHITESPACE.indexOf(text.charAt(tagPos - 1)) > -1)
	{
		--tagPos;
	}

	return tagPos;
}

/**
* Compute the position and priority of a magic start tag, adjusted for whitespace
*
* @param  {!number}   tagPos Leftmost possible position for the tag
* @return {!number[]}        [Tag pos, priority]
*/
function getMagicStartCoords(tagPos)
{
	var nextPos, nextPrio, nextTag, prio;
	if (!tagStack.length)
	{
		// Set the next position outside the text boundaries
		nextPos  = textLen + 1;
		nextPrio = 0;
	}
	else
	{
		nextTag  = tagStack[tagStack.length - 1];
		nextPos  = nextTag.getPos();
		nextPrio = nextTag.getSortPriority();
	}

	// Find the first non-whitespace position before next tag or the end of text
	while (tagPos < nextPos && WHITESPACE.indexOf(text[tagPos]) > -1)
	{
		++tagPos;
	}

	// Set a priority that ensures this tag appears before the next tag
	prio = (tagPos === nextPos) ? nextPrio - 1 : 0;

	return [tagPos, prio];
}

/**
* Test whether given start tag is immediately followed by a closing tag
*
* @param  {!Tag} tag Start tag (including self-closing)
* @return {!boolean}
*/
function isFollowedByClosingTag(tag)
{
	return (!tagStack.length) ? false : tagStack[tagStack.length - 1].canClose(tag);
}

/**
* Process all tags in the stack
*/
function processTags()
{
	if (!tagStack.length)
	{
		return;
	}

	// Initialize the count tables
	for (var tagName in tagsConfig)
	{
		cntOpen[tagName]  = 0;
		cntTotal[tagName] = 0;
	}

	// Process the tag stack, close tags that were left open and repeat until done
	do
	{
		while (tagStack.length)
		{
			if (!tagStackIsSorted)
			{
				sortTags();
			}

			currentTag = tagStack.pop();
			processCurrentTag();
		}

		// Close tags that were left open
		openTags.forEach(function (startTag)
		{
			// NOTE: we add tags in hierarchical order (ancestors to descendants) but since
			//       the stack is processed in LIFO order, it means that tags get closed in
			//       the correct order, from descendants to ancestors
			addMagicEndTag(startTag, textLen);
		});
	}
	while (tagStack.length);
}

/**
* Process current tag
*/
function processCurrentTag()
{
	// Invalidate current tag if tags are disabled and current tag would not close the last open
	// tag and is not a system tag
	if ((context.flags & RULE_IGNORE_TAGS)
	 && !currentTag.canClose(openTags[openTags.length - 1])
	 && !currentTag.isSystemTag())
	{
		currentTag.invalidate();
	}

	var tagPos = currentTag.getPos(),
		tagLen = currentTag.getLen();

	// Test whether the cursor passed this tag's position already
	if (pos > tagPos && !currentTag.isInvalid())
	{
		// Test whether this tag is paired with a start tag and this tag is still open
		var startTag = currentTag.getStartTag();

		if (startTag && openTags.indexOf(startTag) >= 0)
		{
			// Create an end tag that matches current tag's start tag, which consumes as much of
			// the same text as current tag and is paired with the same start tag
			addEndTag(
				startTag.getName(),
				pos,
				Math.max(0, tagPos + tagLen - pos)
			).pairWith(startTag);

			// Note that current tag is not invalidated, it's merely replaced
			return;
		}

		// If this is an ignore tag, try to ignore as much as the remaining text as possible
		if (currentTag.isIgnoreTag())
		{
			var ignoreLen = tagPos + tagLen - pos;

			if (ignoreLen > 0)
			{
				// Create a new ignore tag and move on
				addIgnoreTag(pos, ignoreLen);

				return;
			}
		}

		// Skipped tags are invalidated
		currentTag.invalidate();
	}

	if (currentTag.isInvalid())
	{
		return;
	}

	if (currentTag.isIgnoreTag())
	{
		outputIgnoreTag(currentTag);
	}
	else if (currentTag.isBrTag())
	{
		// Output the tag if it's allowed, ignore it otherwise
		if (!HINT.RULE_PREVENT_BR || !(context.flags & RULE_PREVENT_BR))
		{
			outputBrTag(currentTag);
		}
	}
	else if (currentTag.isParagraphBreak())
	{
		outputText(currentTag.getPos(), 0, true);
	}
	else if (currentTag.isVerbatim())
	{
		outputVerbatim(currentTag);
	}
	else if (currentTag.isStartTag())
	{
		processStartTag(currentTag);
	}
	else
	{
		processEndTag(currentTag);
	}
}

/**
* Process given start tag (including self-closing tags) at current position
*
* @param {!Tag} tag Start tag (including self-closing)
*/
function processStartTag(tag)
{
	var tagName   = tag.getName(),
		tagConfig = tagsConfig[tagName];

	// 1. Check that this tag has not reached its global limit tagLimit
	// 2. Execute this tag's filterChain, which will filter/validate its attributes
	// 3. Apply closeParent, closeAncestor and fosterParent rules
	// 4. Check for nestingLimit
	// 5. Apply requireAncestor rules
	//
	// This order ensures that the tag is valid and within the set limits before we attempt to
	// close parents or ancestors. We need to close ancestors before we can check for nesting
	// limits, whether this tag is allowed within current context (the context may change
	// as ancestors are closed) or whether the required ancestors are still there (they might
	// have been closed by a rule.)
	if (cntTotal[tagName] >= tagConfig.tagLimit)
	{
		logger.err(
			'Tag limit exceeded',
			{
				'tag'      : tag,
				'tagName'  : tagName,
				'tagLimit' : tagConfig.tagLimit
			}
		);
		tag.invalidate();

		return;
	}

	if (!filterTag(tag))
	{
		tag.invalidate();

		return;
	}

	if (currentFixingCost < maxFixingCost)
	{
		if (fosterParent(tag) || closeParent(tag) || closeAncestor(tag))
		{
			// This tag parent/ancestor needs to be closed, we just return (the tag is still valid)
			return;
		}
	}

	if (cntOpen[tagName] >= tagConfig.nestingLimit)
	{
		logger.err(
			'Nesting limit exceeded',
			{
				'tag'          : tag,
				'tagName'      : tagName,
				'nestingLimit' : tagConfig.nestingLimit
			}
		);
		tag.invalidate();

		return;
	}

	if (!tagIsAllowed(tagName))
	{
		var msg     = 'Tag is not allowed in this context',
			context = {'tag': tag, 'tagName': tagName};
		if (tag.getLen() > 0)
		{
			logger.warn(msg, context);
		}
		else
		{
			logger.debug(msg, context);
		}
		tag.invalidate();

		return;
	}

	if (requireAncestor(tag))
	{
		tag.invalidate();

		return;
	}

	// If this tag has an autoClose rule and it's not paired with an end tag or followed by an
	// end tag, we replace it with a self-closing tag with the same properties
	if (HINT.RULE_AUTO_CLOSE
	 && tag.getFlags() & RULE_AUTO_CLOSE
	 && !tag.getEndTag()
	 && !isFollowedByClosingTag(tag))
	{
		var newTag = new Tag(Tag.SELF_CLOSING_TAG, tagName, tag.getPos(), tag.getLen());
		newTag.setAttributes(tag.getAttributes());
		newTag.setFlags(tag.getFlags());

		tag = newTag;
	}

	if (HINT.RULE_TRIM_FIRST_LINE
	 && tag.getFlags() & RULE_TRIM_FIRST_LINE
	 && !tag.getEndTag()
	 && text.charAt(tag.getPos() + tag.getLen()) === "\n")
	{
		addIgnoreTag(tag.getPos() + tag.getLen(), 1);
	}

	// This tag is valid, output it and update the context
	outputTag(tag);
	pushContext(tag);

	// Apply the createChild rules if applicable
	createChild(tag);
}

/**
* Process given end tag at current position
*
* @param {!Tag} tag End tag
*/
function processEndTag(tag)
{
	var tagName = tag.getName();

	if (!cntOpen[tagName])
	{
		// This is an end tag with no start tag
		return;
	}

	/**
	* @type {!Array.<!Tag>} List of tags need to be closed before given tag
	*/
	var closeTags = [];

	// Iterate through all open tags from last to first to find a match for our tag
	var i = openTags.length;
	while (--i >= 0)
	{
		var openTag = openTags[i];

		if (tag.canClose(openTag))
		{
			break;
		}

		closeTags.push(openTag);
		++currentFixingCost;
	}

	if (i < 0)
	{
		// Did not find a matching tag
		logger.debug('Skipping end tag with no start tag', {'tag': tag});

		return;
	}

	// Accumulate flags to determine whether whitespace should be trimmed
	var flags = tag.getFlags();
	closeTags.forEach(function(openTag)
	{
		flags |= openTag.getFlags();
	});
	var ignoreWhitespace = (HINT.RULE_IGNORE_WHITESPACE && (flags & RULE_IGNORE_WHITESPACE));

	// Only reopen tags if we haven't exceeded our "fixing" budget
	var keepReopening = HINT.RULE_AUTO_REOPEN && (currentFixingCost < maxFixingCost),
		reopenTags    = [];
	closeTags.forEach(function(openTag)
	{
		var openTagName = openTag.getName();

		// Test whether this tag should be reopened automatically
		if (keepReopening)
		{
			if (openTag.getFlags() & RULE_AUTO_REOPEN)
			{
				reopenTags.push(openTag);
			}
			else
			{
				keepReopening = false;
			}
		}

		// Find the earliest position we can close this open tag
		var tagPos = tag.getPos();
		if (ignoreWhitespace)
		{
			tagPos = getMagicEndPos(tagPos);
		}

		// Output an end tag to close this start tag, then update the context
		var endTag = new Tag(Tag.END_TAG, openTagName, tagPos, 0);
		endTag.setFlags(openTag.getFlags());
		outputTag(endTag);
		popContext();
	});

	// Output our tag, moving the cursor past it, then update the context
	outputTag(tag);
	popContext();

	// If our fixing budget allows it, peek at upcoming tags and remove end tags that would
	// close tags that are already being closed now. Also, filter our list of tags being
	// reopened by removing those that would immediately be closed
	if (closeTags.length && currentFixingCost < maxFixingCost)
	{
		/**
		* @type {number} Rightmost position of the portion of text to ignore
		*/
		var ignorePos = pos;

		i = tagStack.length;
		while (--i >= 0 && ++currentFixingCost < maxFixingCost)
		{
			var upcomingTag = tagStack[i];

			// Test whether the upcoming tag is positioned at current "ignore" position and it's
			// strictly an end tag (not a start tag or a self-closing tag)
			if (upcomingTag.getPos() > ignorePos
			 || upcomingTag.isStartTag())
			{
				break;
			}

			// Test whether this tag would close any of the tags we're about to reopen
			var j = closeTags.length;

			while (--j >= 0 && ++currentFixingCost < maxFixingCost)
			{
				if (upcomingTag.canClose(closeTags[j]))
				{
					// Remove the tag from the lists and reset the keys
					closeTags.splice(j, 1);

					if (reopenTags[j])
					{
						reopenTags.splice(j, 1);
					}

					// Extend the ignored text to cover this tag
					ignorePos = Math.max(
						ignorePos,
						upcomingTag.getPos() + upcomingTag.getLen()
					);

					break;
				}
			}
		}

		if (ignorePos > pos)
		{
			/**
			* @todo have a method that takes (pos,len) rather than a Tag
			*/
			outputIgnoreTag(new Tag(Tag.SELF_CLOSING_TAG, 'i', pos, ignorePos - pos));
		}
	}

	// Re-add tags that need to be reopened, at current cursor position
	reopenTags.forEach(function(startTag)
	{
		var newTag = addCopyTag(startTag, pos, 0);

		// Re-pair the new tag
		var endTag = startTag.getEndTag();
		if (endTag)
		{
			newTag.pairWith(endTag);
		}
	});
}

/**
* Update counters and replace current context with its parent context
*/
function popContext()
{
	var tag = openTags.pop();
	--cntOpen[tag.getName()];
	context = context.parentContext;
}

/**
* Update counters and replace current context with a new context based on given tag
*
* If given tag is a self-closing tag, the context won't change
*
* @param {!Tag} tag Start tag (including self-closing)
*/
function pushContext(tag)
{
	var tagName   = tag.getName(),
		tagFlags  = tag.getFlags(),
		tagConfig = tagsConfig[tagName];

	++cntTotal[tagName];

	// If this is a self-closing tag, the context remains the same
	if (tag.isSelfClosingTag())
	{
		return;
	}

	// Recompute the allowed tags
	var allowed = [];
	if (HINT.RULE_IS_TRANSPARENT && (tagFlags & RULE_IS_TRANSPARENT))
	{
		context.allowed.forEach(function(v, k)
		{
			allowed.push(tagConfig.allowed[k] & v);
		});
	}
	else
	{
		context.allowed.forEach(function(v, k)
		{
			allowed.push(tagConfig.allowed[k] & ((v & 0xFF00) | (v >> 8)));
		});
	}

	// Use this tag's flags as a base for this context and add inherited rules
	var flags = tagFlags | (context.flags & RULES_INHERITANCE);

	// RULE_DISABLE_AUTO_BR turns off RULE_ENABLE_AUTO_BR
	if (flags & RULE_DISABLE_AUTO_BR)
	{
		flags &= ~RULE_ENABLE_AUTO_BR;
	}

	++cntOpen[tagName];
	openTags.push(tag);
	context = {
		allowed       : allowed,
		flags         : flags,
		parentContext : context
	};
}

/**
* Return whether given tag is allowed in current context
*
* @param  {!string}  tagName
* @return {!boolean}
*/
function tagIsAllowed(tagName)
{
	var n = tagsConfig[tagName].bitNumber;

	return !!(context.allowed[n >> 3] & (1 << (n & 7)));
}

//==========================================================================
// Tag stack
//==========================================================================

/**
* Add a start tag
*
* @param  {!string} name Name of the tag
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @param  {number}  prio Tags' priority
* @return {!Tag}
*/
function addStartTag(name, pos, len, prio)
{
	return addTag(Tag.START_TAG, name, pos, len, prio || 0);
}

/**
* Add an end tag
*
* @param  {!string} name Name of the tag
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @param  {number}  prio Tags' priority
* @return {!Tag}
*/
function addEndTag(name, pos, len, prio)
{
	return addTag(Tag.END_TAG, name, pos, len, prio || 0);
}

/**
* Add a self-closing tag
*
* @param  {!string} name Name of the tag
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @param  {number}  prio Tags' priority
* @return {!Tag}
*/
function addSelfClosingTag(name, pos, len, prio)
{
	return addTag(Tag.SELF_CLOSING_TAG, name, pos, len, prio || 0);
}

/**
* Add a 0-width "br" tag to force a line break at given position
*
* @param  {!number} pos  Position of the tag in the text
* @param  {number}  prio Tags' priority
* @return {!Tag}
*/
function addBrTag(pos, prio)
{
	return addTag(Tag.SELF_CLOSING_TAG, 'br', pos, 0, prio || 0);
}

/**
* Add an "ignore" tag
*
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @param  {number}  prio Tags' priority
* @return {!Tag}
*/
function addIgnoreTag(pos, len, prio)
{
	return addTag(Tag.SELF_CLOSING_TAG, 'i', pos, Math.min(len, textLen - pos), prio || 0);
}

/**
* Add a paragraph break at given position
*
* Uses a zero-width tag that is actually never output in the result
*
* @param  {!number} pos  Position of the tag in the text
* @param  {number}  prio Tags' priority
* @return {!Tag}
*/
function addParagraphBreak(pos, prio)
{
	return addTag(Tag.SELF_CLOSING_TAG, 'pb', pos, 0, prio || 0);
}

/**
* Add a copy of given tag at given position and length
*
* @param  {!Tag}    tag Original tag
* @param  {!number} pos Copy's position
* @param  {!number} len Copy's length
* @param  {number}  prio Tags' priority
* @return {!Tag}         Copy tag
*/
function addCopyTag(tag, pos, len, prio)
{
	var copy = addTag(tag.getType(), tag.getName(), pos, len, tag.getSortPriority());
	copy.setAttributes(tag.getAttributes());

	return copy;
}

/**
* Add a tag
*
* @param  {!number} type Tag's type
* @param  {!string} name Name of the tag
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @param  {number}  prio Tags' priority
* @return {!Tag}
*/
function addTag(type, name, pos, len, prio)
{
	// Create the tag
	var tag = new Tag(type, name, pos, len, prio || 0);

	// Set this tag's rules bitfield
	if (tagsConfig[name])
	{
		tag.setFlags(tagsConfig[name].rules.flags);
	}

	// Invalidate this tag if it's an unknown tag, a disabled tag, if either of its length or
	// position is negative or if it's out of bounds
	if (!tagsConfig[name] && !tag.isSystemTag())
	{
		tag.invalidate();
	}
	else if (tagsConfig[name] && tagsConfig[name].isDisabled)
	{
		logger.warn(
			'Tag is disabled',
			{
				'tag'     : tag,
				'tagName' : name
			}
		);
		tag.invalidate();
	}
	else if (len < 0 || pos < 0 || pos + len > textLen)
	{
		tag.invalidate();
	}
	else
	{
		insertTag(tag);
	}

	return tag;
}

/**
* Insert given tag in the tag stack
*
* @param {!Tag} tag
*/
function insertTag(tag)
{
	if (!tagStackIsSorted)
	{
		tagStack.push(tag);
	}
	else
	{
		// Scan the stack and copy every tag to the next slot until we find the correct index
		var i = tagStack.length;
		while (i > 0 && compareTags(tagStack[i - 1], tag) > 0)
		{
			tagStack[i] = tagStack[i - 1];
			--i;
		}
		tagStack[i] = tag;
	}
}

/**
* Add a pair of tags
*
* @param  {!string} name     Name of the tags
* @param  {!number} startPos Position of the start tag
* @param  {!number} startLen Length of the start tag
* @param  {!number} endPos   Position of the start tag
* @param  {!number} endLen   Length of the start tag
* @param  {number}  prio     Start tag's priority (the end tag will be set to minus that value)
* @return {!Tag}             Start tag
*/
function addTagPair(name, startPos, startLen, endPos, endLen, prio)
{
	// NOTE: the end tag is added first to try to keep the stack in the correct order
	var endTag   = addEndTag(name, endPos, endLen, -prio || 0),
		startTag = addStartTag(name, startPos, startLen, prio || 0);
	startTag.pairWith(endTag);

	return startTag;
}

/**
* Add a tag that represents a verbatim copy of the original text
*
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @return {!Tag}
*/
function addVerbatim(pos, len, prio)
{
	return addTag(Tag.SELF_CLOSING_TAG, 'v', pos, len, prio || 0);
}

/**
* Sort tags by position and precedence
*/
function sortTags()
{
	tagStack.sort(compareTags);
	tagStackIsSorted = true;
}

/**
* sortTags() callback
*
* Tags are stored as a stack, in LIFO order. We sort tags by position _descending_ so that they
* are processed in the order they appear in the text.
*
* @param  {!Tag}    a First tag to compare
* @param  {!Tag}    b Second tag to compare
* @return {!number}
*/
function compareTags(a, b)
{
	var aPos = a.getPos(),
		bPos = b.getPos();

	// First we order by pos descending
	if (aPos !== bPos)
	{
		return bPos - aPos;
	}

	// If the tags start at the same position, we'll use their sortPriority if applicable. Tags
	// with a lower value get sorted last, which means they'll be processed first. IOW, -10 is
	// processed before 10
	if (a.getSortPriority() !== b.getSortPriority())
	{
		return b.getSortPriority() - a.getSortPriority();
	}

	// If the tags start at the same position and have the same priority, we'll sort them
	// according to their length, with special considerations for  zero-width tags
	var aLen = a.getLen(),
		bLen = b.getLen();

	if (!aLen || !bLen)
	{
		// Zero-width end tags are ordered after zero-width start tags so that a pair that ends
		// with a zero-width tag has the opportunity to be closed before another pair starts
		// with a zero-width tag. For example, the pairs that would enclose each of the letters
		// in the string "XY". Self-closing tags are ordered between end tags and start tags in
		// an attempt to keep them out of tag pairs
		if (!aLen && !bLen)
		{
			var order = {};
			order[Tag.END_TAG]          = 0;
			order[Tag.SELF_CLOSING_TAG] = 1;
			order[Tag.START_TAG]        = 2;

			return order[b.getType()] - order[a.getType()];
		}

		// Here, we know that only one of a or b is a zero-width tags. Zero-width tags are
		// ordered after wider tags so that they have a chance to be processed before the next
		// character is consumed, which would force them to be skipped
		return (aLen) ? -1 : 1;
	}

	// Here we know that both tags start at the same position and have a length greater than 0.
	// We sort tags by length ascending, so that the longest matches are processed first. If
	// their length is identical, the order is undefined as PHP's sort isn't stable
	return aLen - bLen;
}
var MSXML = (typeof DOMParser === 'undefined' || typeof XSLTProcessor === 'undefined');
var xslt = {
	/**
	* @param {!string} xsl
	*/
	init: function(xsl)
	{
		var stylesheet = xslt.loadXML(xsl, 'MSXML2.FreeThreadedDOMDocument.6.0');
		if (MSXML)
		{
			var generator = new ActiveXObject("MSXML2.XSLTemplate.6.0");
			generator['stylesheet'] = stylesheet;
			xslt.proc = generator['createProcessor']();
		}
		else
		{
			xslt.proc = new XSLTProcessor;
			xslt.proc['importStylesheet'](stylesheet);
		}
	},

	/**
	* @param {!string} xml
	* @param {string} type
	*/
	loadXML: function(xml, type)
	{
		if (MSXML)
		{
			var dom = new ActiveXObject(type);
			dom['async'] = false;
			dom['validateOnParse'] = false;
			dom['loadXML'](xml);

			return dom;
		}

		return (new DOMParser).parseFromString(xml, 'text/xml');
	},

	/**
	* @param {!string} paramName  Parameter name
	* @param {!string} paramValue Parameter's value
	*/
	setParameter: function(paramName, paramValue)
	{
		if (MSXML)
		{
			xslt.proc['addParameter'](paramName, paramValue, '');
		}
		else
		{
			xslt.proc['setParameter'](null, paramName, paramValue);
		}
	},

	/**
	* @param {!string} xml
	* @param {!HTMLDocument} targetDoc
	*/
	transformToFragment: function(xml, targetDoc)
	{
		if (MSXML)
		{
			var div = targetDoc.createElement('div'),
				fragment = targetDoc.createDocumentFragment();

			xslt.proc['input'] = xslt.loadXML(xml, 'MSXML2.DOMDocument.6.0');
			xslt.proc['transform']();
			div.innerHTML = xslt.proc['output'];
			while (div.firstChild)
			{
				fragment.appendChild(div.removeChild(div.firstChild));
			}

			return fragment;
		}

		// NOTE: importNode() is used because of https://code.google.com/p/chromium/issues/detail?id=266305
		return targetDoc.importNode(xslt.proc['transformToFragment'](xslt.loadXML(xml), targetDoc), true);
	}
}
xslt.init(xsl);

var postProcessFunctions = {};

/**
* Parse a given text and render it into given HTML element
*
* @param {!string} text
* @param {!HTMLElement} target
*/
function preview(text, target)
{
	var targetDoc = target.ownerDocument,
		resultFragment = xslt.transformToFragment(parse(text), targetDoc);

	// Apply post-processing
	if (HINT.postProcessing)
	{
		var nodes = resultFragment['querySelectorAll']('[data-s9e-livepreview-postprocess]'),
			i     = nodes.length;
		while (--i >= 0)
		{
			/** @type {!string} */
			var code = nodes[i]['getAttribute']('data-s9e-livepreview-postprocess');

			if (!postProcessFunctions[code])
			{
				postProcessFunctions[code] = new Function(code);
			}

			postProcessFunctions[code]['call'](nodes[i]);
		}
	}

	/**
	* Update the content of given element oldEl to match element newEl
	*
	* @param {!HTMLElement} oldEl
	* @param {!HTMLElement} newEl
	*/
	function refreshElementContent(oldEl, newEl)
	{
		var oldNodes = oldEl.childNodes,
			newNodes = newEl.childNodes,
			oldCnt = oldNodes.length,
			newCnt = newNodes.length,
			oldNode,
			newNode,
			left  = 0,
			right = 0;

		// Skip the leftmost matching nodes
		while (left < oldCnt && left < newCnt)
		{
			oldNode = oldNodes[left];
			newNode = newNodes[left];

			if (!refreshNode(oldNode, newNode))
			{
				break;
			}

			++left;
		}

		// Skip the rightmost matching nodes
		var maxRight = Math.min(oldCnt - left, newCnt - left);

		while (right < maxRight)
		{
			oldNode = oldNodes[oldCnt - (right + 1)];
			newNode = newNodes[newCnt - (right + 1)];

			if (!refreshNode(oldNode, newNode))
			{
				break;
			}

			++right;
		}

		// Clone the new nodes
		var newNodesFragment = targetDoc.createDocumentFragment(),
			i = left;

		while (i < (newCnt - right))
		{
			newNode = newNodes[i].cloneNode(true);

			newNodesFragment.appendChild(newNode);
			++i;
		}

		// Remove the old dirty nodes in the middle of the tree
		i = oldCnt - right;
		while (--i >= left)
		{
			oldEl.removeChild(oldNodes[i]);
		}

		// If we haven't skipped any nodes to the right, we can just append the fragment
		if (!right)
		{
			oldEl.appendChild(newNodesFragment);
		}
		else
		{
			oldEl.insertBefore(newNodesFragment, oldEl.childNodes[left]);
		}
	}

	/**
	* Update given node oldNode to make it match newNode
	*
	* @param {!HTMLElement} oldNode
	* @param {!HTMLElement} newNode
	* @return boolean Whether the node can be skipped
	*/
	function refreshNode(oldNode, newNode)
	{
		if (oldNode.nodeName !== newNode.nodeName
		 || oldNode.nodeType !== newNode.nodeType)
		{
			return false;
		}

		// Node.TEXT_NODE || Node.COMMENT_NODE
		if (oldNode.nodeType === 3 || oldNode.nodeType === 8)
		{
			if (oldNode.nodeValue !== newNode.nodeValue)
			{
				oldNode.nodeValue = newNode.nodeValue;
			}

			return true;
		}

		if (oldNode.isEqualNode && oldNode.isEqualNode(newNode))
		{
			return true;
		}

		syncElementAttributes(oldNode, newNode);
		refreshElementContent(oldNode, newNode);

		return true;
	}

	/**
	* Make the set of attributes of given element oldEl match newEl's
	*
	* @param {!HTMLElement} oldEl
	* @param {!HTMLElement} newEl
	*/
	function syncElementAttributes(oldEl, newEl)
	{
		var oldAttributes = oldEl['attributes'],
			newAttributes = newEl['attributes'],
			oldCnt = oldAttributes.length,
			newCnt = newAttributes.length,
			i = oldCnt;

		while (--i >= 0)
		{
			var oldAttr      = oldAttributes[i],
				namespaceURI = oldAttr['namespaceURI'],
				attrName     = oldAttr['name'];

			if (!newEl.hasAttributeNS(namespaceURI, attrName))
			{
				oldEl.removeAttributeNS(namespaceURI, attrName);
			}
		}

		i = newCnt;
		while (--i >= 0)
		{
			var newAttr      = newAttributes[i],
				namespaceURI = newAttr['namespaceURI'],
				attrName     = newAttr['name'],
				attrValue    = newAttr['value'];

			if (attrValue !== oldEl.getAttributeNS(namespaceURI, attrName))
			{
				oldEl.setAttributeNS(namespaceURI, attrName, attrValue);
			}
		}
	}

	refreshElementContent(target, resultFragment);
}

/**
* Set the value of a stylesheet parameter
*
* @param {!string} paramName  Parameter name
* @param {!string} paramValue Parameter's value
*/
function setParameter(paramName, paramValue)
{
	xslt.setParameter(paramName, paramValue);
}
if (!window['s9e']) window['s9e'] = {};
window['s9e']['TextFormatter'] = {'preview':preview}})()</script>




    <div class="sidebar">
                <!--AdFox START-->
        <!--autoreview.ru-->
        <!--Площадка: autoreview.ru / * / *-->
        <!--Тип баннера: sidebar_top-->
        <!--Расположение: <верх страницы>-->
        <script type="text/javascript">
            <!--
            if (typeof(pr) == 'undefined') { var pr = Math.floor(Math.random() * 4294967295) + 1; }
            if (typeof(document.referrer) != 'undefined') {
                if (typeof(afReferrer) == 'undefined') {
                    afReferrer = encodeURIComponent(document.referrer);
                }
            } else {
                afReferrer = '';
            }
            var addate = new Date();
            document.write('<scr' + 'ipt type="text/javascript" src="//ads.adfox.ru/246035/prepareCode?pp=g&amp;ps=cfot&amp;p2=fivd&amp;pct=a&amp;plp=a&amp;pli=a&amp;pop=a&amp;pr=' + pr +'&amp;pt=b&amp;pd=' + addate.getDate() + '&amp;pw=' + addate.getDay() + '&amp;pv=' + addate.getHours() + '&amp;prr=' + afReferrer + '"><\/scr' + 'ipt>');
            // -->
        </script>
        <!--AdFox END-->
        <!--AdFox START-->
        <!--autoreview.ru-->
        <!--Площадка: autoreview.ru / * / *-->
        <!--Тип баннера: sidebar_top_240x200-->
        <!--Расположение: <верх страницы>-->
        <script type="text/javascript">
            <!--
            if (typeof(pr) == 'undefined') { var pr = Math.floor(Math.random() * 4294967295) + 1; }
            if (typeof(document.referrer) != 'undefined') {
                if (typeof(afReferrer) == 'undefined') {
                    afReferrer = encodeURIComponent(document.referrer);
                }
            } else {
                afReferrer = '';
            }
            var addate = new Date();
            document.write('<scr' + 'ipt type="text/javascript" src="//ads.adfox.ru/246035/prepareCode?pp=g&amp;ps=cfot&amp;p2=fjia&amp;pct=a&amp;plp=a&amp;pli=a&amp;pop=a&amp;pr=' + pr +'&amp;pt=b&amp;pd=' + addate.getDate() + '&amp;pw=' + addate.getDay() + '&amp;pv=' + addate.getHours() + '&amp;prr=' + afReferrer + '"><\/scr' + 'ipt>');
            // -->
        </script>
        <!--AdFox END-->
        <!--AdFox START-->
        <!--autoreview.ru-->
        <!--Площадка: autoreview.ru / * / *-->
        <!--Тип баннера: sidebar_300_600-->
        <!--Расположение: <верх страницы>-->
        <script type="text/javascript">
            <!--
            if (typeof(pr) == 'undefined') { var pr = Math.floor(Math.random() * 4294967295) + 1; }
            if (typeof(document.referrer) != 'undefined') {
                if (typeof(afReferrer) == 'undefined') {
                    afReferrer = encodeURIComponent(document.referrer);
                }
            } else {
                afReferrer = '';
            }
            var addate = new Date();
            document.write('<scr' + 'ipt type="text/javascript" src="//ads.adfox.ru/246035/prepareCode?pp=g&amp;ps=cfot&amp;p2=fkvj&amp;pct=a&amp;plp=a&amp;pli=a&amp;pop=a&amp;pr=' + pr +'&amp;pt=b&amp;pd=' + addate.getDate() + '&amp;pw=' + addate.getDay() + '&amp;pv=' + addate.getHours() + '&amp;prr=' + afReferrer + '"><\/scr' + 'ipt>');
            // -->
        </script>
        <!--AdFox END-->
        
        <div class="sidebar-them">
            <div class="sidebar-them-title">Горячие темы</div>
            <div class="sidebar-them-wrapp">
                                    <div class="item" data-href="https://autoreview.ru/articles/pervaya-vstrecha/cross-list">
                        <div class="item-img" style="background-image: url('/images/Article/1607/Article_160732_305_204.jpg')">
                            <span class="item-img-comments">818</span>
                        <span class="item-img-border">
                            <span class="item-img-border-fire"></span>
                        </span>
                        </div>
                        <div class="item-content">Лада Веста SW Cross: ездовой экзамен</div>
                    </div>
                                    <div class="item" data-href="https://autoreview.ru/news/krossover-toyota-highlander-stal-zametno-dostupnee">
                        <div class="item-img" style="background-image: url('/images/Article/1608/Article_160856_305_204.jpg')">
                            <span class="item-img-comments">195</span>
                        <span class="item-img-border">
                            <span class="item-img-border-fire"></span>
                        </span>
                        </div>
                        <div class="item-content">Кроссовер Toyota Highlander стал заметно доступнее</div>
                    </div>
                                    <div class="item" data-href="https://autoreview.ru/articles/shiny/wintertest-r16-2017">
                        <div class="item-img" style="background-image: url('/images/Article/1605/Article_160544_305_204.jpg')">
                            <span class="item-img-comments">378</span>
                        <span class="item-img-border">
                            <span class="item-img-border-fire"></span>
                        </span>
                        </div>
                        <div class="item-content">Брак не по расчету: испытываем 23 комплекта зимних шин</div>
                    </div>
                                    <div class="item" data-href="https://autoreview.ru/news/skoda-okazalas-slishkom-uspeshnoy-volkswagen-gotovit-sankcii">
                        <div class="item-img" style="background-image: url('/images/Article/1608/Article_160891_305_204.jpg')">
                            <span class="item-img-comments">61</span>
                        <span class="item-img-border">
                            <span class="item-img-border-fire"></span>
                        </span>
                        </div>
                        <div class="item-content">Skoda оказалась слишком успешной: Volkswagen готовит санкции</div>
                    </div>
                                    <div class="item" data-href="https://autoreview.ru/news/vesta-pervoy-obzavedetsya-sistemoy-lada-connect-v-2018-godu">
                        <div class="item-img" style="background-image: url('/images/Article/1608/Article_160871_305_204.jpg')">
                            <span class="item-img-comments">68</span>
                        <span class="item-img-border">
                            <span class="item-img-border-fire"></span>
                        </span>
                        </div>
                        <div class="item-content">Веста первой обзаведется системой Lada Connect в 2018 году</div>
                    </div>
                            </div>
        </div>

        <div class="sidebar-discussing">
            <div class="sidebar-discussing-title">Сейчас обсуждают</div>
            <div class="sidebar-discussing-wrapp">
                                    <a class="item" href="https://autoreview.ru/news/skoda-okazalas-slishkom-uspeshnoy-volkswagen-gotovit-sankcii#!comment=1043419">
                        <div class="item-autor">
                            <img src="/images/Avatar/11700/Avatar_1170092_45_45.jpg" alt="">
                            <span>михаил отрешко</span>
                        </div>
                        <div class="item-text shadow">Странные они люди. Сначала причесывают октавию под джетту, суперб под пассат, а кодьяк под тигуан, а потом не понимают почему vw хуже продается. Сейчас ещё и карок выйдет, который ещё и продажи …</div>
                    </a>
                                    <a class="item" href="https://autoreview.ru/news/skoda-okazalas-slishkom-uspeshnoy-volkswagen-gotovit-sankcii#!comment=1043399">
                        <div class="item-autor">
                            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAL4AAAC+CAIAAAAEFiLKAAAABnRSTlMAAAAAAABupgeRAAABlElEQVR4nO3dwQ3CMBAAwQSlUEqgBEqgBErlyxOtbGIpMwWcHGWVvE7eNgAAAAAAAAAAAAAAAAAAAK5qnzH0dX/OGEvzeD9njL3NGMoVSIdIOkTSIZIOkXSIpEMkHSLpEEmHSDpE0iGSDpF0iKRDJB0i6RBJh0g6RNIhkg6RdIikQyQdIukQSYfoOPsAPxm7+jp8r3nx403iq0MkHSLpEEmHSDpE0iGSDpF0iKRDJB0i6RBJh0g6RNIhkg6RdIikQyQdIukQSYdIOkTSIZIOkXSIpEMkHQAAAAAAAAAAAAAAAACAlewzhq5/e+XA2zov9bDfLA4TSYdIOkTSIZIOkXSIpEMkHSLpEEmHSDpE0iGSDpF0iKRDJB0i6RBJh0g6RNIhkg6RdIikQyQdIukQSYfoOPsA51h/23d9U3bOx7rga560JT6WHxaRdIikQyQdIukQSYdIOkTSIZIOkXSIpEMkHSLpEEmHSDpE0iGSDpF0iKRDJB0i6RBJh0g6RNIhkg4AAAAAAAAAAAAAAAAAAAAA//EBfikUSh3bgXwAAAAASUVORK5CYII=" alt="">
                            <span>Сергей</span>
                        </div>
                        <div class="item-text shadow">Глупости, порше некисло денег в кассу приносит (самая большая маржа в мире с 1 авто).
VW вкладывается в технологии, оттого финальная прибыль мизерная, шкода же на подсосе, пользуется уже готовыми проверенными решениями, отсюда …</div>
                    </a>
                                    <a class="item" href="https://autoreview.ru/news/skoda-okazalas-slishkom-uspeshnoy-volkswagen-gotovit-sankcii#!comment=1043404">
                        <div class="item-autor">
                            <img src="/images/Avatar/11494/Avatar_1149444_45_45.jpg" alt="">
                            <span>Николай Савченко</span>
                        </div>
                        <div class="item-text">Пусть в России производство расширяют.Универсалы Октавия наконец выпускать начнут,Скауты теже!
</div>
                    </a>
                                    <a class="item" href="https://autoreview.ru/news/skoda-okazalas-slishkom-uspeshnoy-volkswagen-gotovit-sankcii#!comment=1043411">
                        <div class="item-autor">
                            <img src="/images/Avatar/11498/Avatar_1149864_45_45.jpg" alt="">
                            <span>Валерий</span>
                        </div>
                        <div class="item-text shadow">Совет директоров, он же верховные продажники-мархетологи:
"Я недоволен своей правой ногой, она сильнее левой. А дай ка я её сломаю немного, и тогда левая у меня окрепнет, а правую в случае чего отнимут."

Почему …</div>
                    </a>
                                    <a class="item" href="https://autoreview.ru/news/skoda-okazalas-slishkom-uspeshnoy-volkswagen-gotovit-sankcii#!comment=1043395">
                        <div class="item-autor">
                            <img src="/images/Avatar/11681/Avatar_1168183_45_45.jpg" alt="">
                            <span>HATAXA</span>
                        </div>
                        <div class="item-text shadow">А что удивительного? Всегда и везде кассу делают не гламурные условные Бугатти, а серые мышки условные Короллы. Фольцвагон просто полез не туда, где бабло водится, и в результате получил по шапке. Вывод …</div>
                    </a>
                            </div>
        </div>

        <a href="/articles/vtorye-ruki" class="sidebar-oldcars">
            <img src="/static/img/sidebar/old-car.jpg">
            <p>Наша экспертиза<br>подержанных автомобилей</p>
        </a>

        <a href="https://autoreview.ru/arcap" class="sidebar-arcap">
            <img src="/static/img/arcap_logo-min.png" class="logo">
            <div id="videoContainer">
                <video autoplay loop poster="/static/mp4/arcap.jpg" style="width: 100%;">
                    <source src="/static/mp4/arcap.mp4" type="video/mp4">
                </video>
            </div>
        </a>

                    <a href="/articles/autosport" class="sidebar-sport"></a>
        
        

                <!--AdFox START-->
        <!--autoreview.ru-->
        <!--Площадка: autoreview.ru / * / *-->
        <!--Тип баннера: sidebar(под марками)-->
        <!--Расположение: <верх страницы>-->
        <script type="text/javascript">
            <!--
            if (typeof(pr) == 'undefined') { var pr = Math.floor(Math.random() * 4294967295) + 1; }
            if (typeof(document.referrer) != 'undefined') {
                if (typeof(afReferrer) == 'undefined') {
                    afReferrer = encodeURIComponent(document.referrer);
                }
            } else {
                afReferrer = '';
            }
            var addate = new Date();
            document.write('<scr' + 'ipt type="text/javascript" src="//ads.adfox.ru/246035/prepareCode?pp=g&amp;ps=cfot&amp;p2=fjyg&amp;pct=a&amp;plp=a&amp;pli=a&amp;pop=a&amp;pr=' + pr +'&amp;pt=b&amp;pd=' + addate.getDate() + '&amp;pw=' + addate.getDay() + '&amp;pv=' + addate.getHours() + '&amp;prr=' + afReferrer + '"><\/scr' + 'ipt>');
            // -->
        </script>
        <!--AdFox END-->
        
        <div class="sidebar-white newsletter">
            <p class="title">Рассылка</p>
            <p class="text">Лучшие материалы Авторевю — в вашем почтовом ящике</p>
            <form method="POST" action="https://autoreview.ru/ajax/subscribe" accept-charset="UTF-8">
                <input class="input email" placeholder="Ваш e-mail" name="email" type="email">
                <input type="hidden" name="_token" value="pGZU6ssbtGqI9d0cPOq4poooNEsWr8SKIzYxhuJs">
                <input class="button" type="submit" value="Отправить">
            </form>
            <p style="font-size: 13px;line-height: 1.5;color: #aaa;">Предоставляя e-mail, вы подтверждаете свое согласие с условиями <a href="/policy" target="_blank" style="color: #777;">политики конфиденциальности</a></p>
        </div>

        <a href="https://autoreview.ru/parking" class="sidebar-white link parking">
            <p class="title">Парковка Авторевю</p>
            <p class="text">Узнайте, какие автомобили сейчас на испытаниях</p>
        </a>
        <a href="https://autoreview.ru/location" class="sidebar-white link location">
            <p class="title">Кто где?</p>
            <p class="text">Где работают журналисты Авторевю прямо сейчас</p>
        </a>
            
    </div>
</div>
